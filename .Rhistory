color = "grey",
size = X.df$weight.trans/max(X.df$weight.trans)*15,
alpha = 0.75) +
new_theme_empty +
geom_point(data = X_info[[2]], aes(x = x, y = y, fill = vertex.names))
ggplot(X.df) +
geom_segment(data = X.df, aes(x = x.1, xend = x.500, y = y.1, yend = y.500),
color = "grey",
size = X.df$weight.trans/max(X.df$weight.trans)*15,
alpha = 0.75) +
new_theme_empty +
geom_point(data = filter(X_info[[2]], y > 1), aes(x = x, y = y, fill = vertex.names), shape = 25)
spectral
library("RColorBrewer", lib.loc="/Library/Frameworks/R.framework/Versions/3.0/Resources/library")
library(RColorBrewer)
brewer.pal(10, "Spectral")
nodeinfo.df
ggplot(X.df) +
geom_segment(data = X.df, aes(x = x.1, xend = x.500, y = y.1, yend = y.500),
color = "grey",
size = X.df$weight.trans/max(X.df$weight.trans)*15,
alpha = 0.75) +
new_theme_empty +
geom_point(data = filter(X_info[[2]], y > 1), aes(x = x, y = y, fill = vertex.names), shape = 25) +
scale_fill_brewer()
ggplot(X.df) +
geom_segment(data = X.df, aes(x = x.1, xend = x.500, y = y.1, yend = y.500),
color = "grey",
size = X.df$weight.trans/max(X.df$weight.trans)*15,
alpha = 0.75) +
new_theme_empty +
geom_point(data = filter(X_info[[2]], y > 1), aes(x = x, y = y, fill = vertex.names), shape = 25) +
geom_point(data = filter(X_info[[2]], y = 1), aes(x = x, y = y, fill = vertex.names), shape = 25) +
scale_fill_brewer()
ggplot(X.df) +
geom_segment(data = X.df, aes(x = x.1, xend = x.500, y = y.1, yend = y.500),
color = "grey",
size = X.df$weight.trans/max(X.df$weight.trans)*15,
alpha = 0.75) +
new_theme_empty +
geom_point(data = filter(X_info[[2]], y > 1), aes(x = x, y = y, fill = vertex.names), shape = 25) +
geom_point(data = filter(X_info[[2]], y == 1), aes(x = x, y = y, fill = vertex.names), shape = 25) +
scale_fill_brewer()
ggplot(X.df) +
geom_segment(data = X.df, aes(x = x.1, xend = x.500, y = y.1, yend = y.500),
color = "grey",
size = X.df$weight.trans/max(X.df$weight.trans)*15,
alpha = 0.75) +
new_theme_empty +
geom_point(data = filter(X_info[[2]], y > 1), aes(x = x, y = y, fill = vertex.names),
shape = 25, size = 15) +
geom_point(data = filter(X_info[[2]], y == 1), aes(x = x, y = y, fill = vertex.names),
shape = 21, size = 15) +
scale_fill_brewer()
ggplot(X.df) +
geom_segment(data = X.df, aes(x = x.1, xend = x.500, y = y.1, yend = y.500),
color = "grey",
size = X.df$weight.trans/max(X.df$weight.trans)*15,
alpha = 0.75) +
new_theme_empty +
geom_point(data = filter(X_info[[2]], y > 1), aes(x = x, y = y, fill = vertex.names),
shape = 25, size = 15) +
geom_point(data = filter(X_info[[2]], y == 1), aes(x = x, y = y, fill = vertex.names),
shape = 21, size = 15) +
scale_fill_brewer(palette = "Spectral")
brewer.pal("Spectral")
brewer.pal(11, "Spectral")
brewer.pal(12, "Spectral")
brewer.pal(11, "Spectral")
metaplot.col <- brewer.pal(11, "Spectral")
eulo.col <- metaplot.col[2]
cecid.col <- metaplot.col[1]
lesto.col <- metaplot.col[3]
meso.col <- metaplot.col[4]
mym.col <- metaplot.col[5]
platy.col <- metaplot.col[7]
rab.bud.col <- metaplot.col[8]
rab.stem.col <- metaplot.col[9]
tory.col <- metaplot.col[10]
iteo.col <- metaplot.col[11]
X_info[[2]]
X.nodes <- X_info[[2]] %>%
mutate(colrs = c(rab.bud.col, iteo.col, eulo.col, meso.col, platy.col, tory.col))
X.nodes
ggplot(X.df) +
geom_segment(data = X.df, aes(x = x.1, xend = x.500, y = y.1, yend = y.500),
color = "grey",
size = X.df$weight.trans/max(X.df$weight.trans)*15,
alpha = 0.75) +
new_theme_empty +
geom_point(data = filter(X.nodes, y > 1), aes(x = x, y = y, fill = vertex.names),
shape = 25, size = 15) +
geom_point(data = filter(X.nodes, y == 1), aes(x = x, y = y, fill = vertex.names),
shape = 21, size = 15) +
scale_fill_manual(values = X.nodes$colrs)
X.nodes$colrs
metaplot.col
plot(metaplot.col)
plot(1:11, col = metaplot.col)
plot(1:11, col = metaplot.col, bg = metaplot.col)
iteo.col
X.nodes
X.nodes <- X_info[[2]] %>%
mutate(colrs = c(rab.bud.col, iteo.col, eulo.col, meso.col, platy.col, tory.col)) %>%
arrange(vertex.names)
X.nodes
ggplot(X.df) +
geom_segment(data = X.df, aes(x = x.1, xend = x.500, y = y.1, yend = y.500),
color = "grey",
size = X.df$weight.trans/max(X.df$weight.trans)*15,
alpha = 0.75) +
new_theme_empty +
geom_point(data = filter(X.nodes, y > 1), aes(x = x, y = y, fill = vertex.names),
shape = 25, size = 15) +
geom_point(data = filter(X.nodes, y == 1), aes(x = x, y = y, fill = vertex.names),
shape = 21, size = 15) +
scale_fill_manual(values = X.nodes$colrs)
ggplot(X.df) +
geom_segment(data = X.df, aes(x = x.1, xend = x.500, y = y.1, yend = y.500),
color = "grey",
size = X.df$weight.trans/max(X.df$weight.trans)*15,
alpha = 0.75) +
new_theme_empty +
geom_point(data = filter(X.nodes, y > 1), aes(x = x, y = y, fill = vertex.names),
shape = 25, size = 15) +
geom_point(data = filter(X.nodes, y == 1), aes(x = x, y = y, fill = vertex.names),
shape = 21, size = 15) +
scale_fill_manual(values = X.nodes$colrs, guide = "none")
X.plot
gtX <- ggplot_gtable(ggplot_build(X.plot))
gtX$layout$clip[gtX$layout$name == "panel"] <- "off"
grid.draw(gtX)
X.plot <- ggplot(X.df) +
geom_segment(data = X.df, aes(x = x.1, xend = x.500, y = y.1, yend = y.500),
color = "grey",
size = X.df$weight.trans/max(X.df$weight.trans)*15,
alpha = 0.75) +
new_theme_empty +
geom_point(data = filter(X.nodes, y > 1), aes(x = x, y = y, fill = vertex.names),
shape = 25, size = 15) +
geom_point(data = filter(X.nodes, y == 1), aes(x = x, y = y, fill = vertex.names),
shape = 21, size = 15) +
scale_fill_manual(values = X.nodes$colrs, guide = "none")
X.plot
gtX <- ggplot_gtable(ggplot_build(X.plot))
gtX$layout$clip[gtX$layout$name == "panel"] <- "off"
grid.draw(gtX)
#s
X.plot <- ggplot(X.df) +
geom_segment(data = X.df, aes(x = x.1, xend = x.500, y = y.1, yend = y.500),
color = "grey",
size = X.df$weight.trans/max(X.df$weight.trans)*15,
alpha = 0.75) +
new_theme_empty +
geom_point(data = filter(X.nodes, y > 1), aes(x = x, y = y, fill = vertex.names),
shape = 25, size = 30) +
geom_point(data = filter(X.nodes, y == 1), aes(x = x, y = y, fill = vertex.names),
shape = 21, size = 30) +
scale_fill_manual(values = X.nodes$colrs, guide = "none")
X.plot
gtX <- ggplot_gtable(ggplot_build(X.plot))
gtX$layout$clip[gtX$layout$name == "panel"] <- "off"
grid.draw(gtX)
#
tree_net_vis
F_info <- bipartite_plot_info(web = tree_net_vis$F, order.type = "normal")
F_info
F_info <- bipartite_plot_info(web = tree_net_vis$F, order.type = "normal")
F.df <- F_info[[1]] %>%
filter(Sequence == 500 | Sequence == 1) %>%
reshape(idvar = "Group", timevar = "Sequence", direction = "wide") %>%
mutate(weight.trans = Weight.1) # unscaled weights
F.nodes <- F_info[[2]] %>%
mutate(colrs = c(cecid.col, iteo.col, eulo.col, meso.col, tory.col)) %>%
arrange(vertex.names)
F.plot <- ggplot(F.df) +
geom_segment(data = F.df, aes(x = x.1, xend = x.500, y = y.1, yend = y.500),
color = "grey",
size = F.df$weight.trans/max(F.df$weight.trans)*15,
alpha = 0.75) +
new_theme_empty +
geom_point(data = filter(F.nodes, y > 1), aes(x = x, y = y, fill = vertex.names),
shape = 25, size = 30) +
geom_point(data = filter(F.nodes, y == 1), aes(x = x, y = y, fill = vertex.names),
shape = 21, size = 30) +
scale_fill_manual(values = F.nodes$colrs, guide = "none")
F.plot
gtF <- ggplot_gtable(ggplot_build(F.plot))
gtF$layout$clip[gtF$layout$name == "panel"] <- "off"
grid.draw(gtF)
x.df
X.df
max.seg.wt <- 22
X.plot <- ggplot(X.df) +
geom_segment(data = X.df, aes(x = x.1, xend = x.500, y = y.1, yend = y.500),
color = "grey",
size = X.df$weight.trans/max.seg.wt*15,
alpha = 0.75) +
new_theme_empty +
geom_point(data = filter(X.nodes, y > 1), aes(x = x, y = y, fill = vertex.names),
shape = 25, size = 30) +
geom_point(data = filter(X.nodes, y == 1), aes(x = x, y = y, fill = vertex.names),
shape = 21, size = 30) +
scale_fill_manual(values = X.nodes$colrs, guide = "none")
X.plot
gtX <- ggplot_gtable(ggplot_build(X.plot))
gtX$layout$clip[gtX$layout$name == "panel"] <- "off"
grid.draw(gtX)
#scale_fill_brewer(palette = "Spectral")
ggplot(F.df) +
geom_segment(data = F.df, aes(x = x.1, xend = x.500, y = y.1, yend = y.500),
color = "grey",
size = F.df$weight.trans/max.seg.wt*15,
alpha = 0.75) +
new_theme_empty +
geom_point(data = filter(F.nodes, y > 1), aes(x = x, y = y, fill = vertex.names),
shape = 25, size = 30) +
geom_point(data = filter(F.nodes, y == 1), aes(x = x, y = y, fill = vertex.names),
shape = 21, size = 30) +
scale_fill_manual(values = F.nodes$colrs, guide = "none")
F.plot
gtF <- ggplot_gtable(ggplot_build(F.plot))
gtF$layout$clip[gtF$layout$name == "panel"] <- "off"
grid.draw(gtF)
F.df
F.df$weight.trans/max.seg.wt*15
X.df$weight.trans/max.seg.wt*15
ggplot(F.df) +
geom_segment(data = F.df, aes(x = x.1, xend = x.500, y = y.1, yend = y.500),
color = "grey",
size = F.df$weight.trans/max.seg.wt*15,
alpha = 0.75) +
new_theme_empty +
geom_point(data = filter(F.nodes, y > 1), aes(x = x, y = y, fill = vertex.names),
shape = 25, size = 30) +
geom_point(data = filter(F.nodes, y == 1), aes(x = x, y = y, fill = vertex.names),
shape = 21, size = 30) +
scale_fill_manual(values = F.nodes$colrs, guide = "none")
F.plot
gtF <- ggplot_gtable(ggplot_build(F.plot))
gtF$layout$clip[gtF$layout$name == "panel"] <- "off"
grid.draw(gtF)
ggplot(F.df) +
geom_segment(data = F.df, aes(x = x.1, xend = x.500, y = y.1, yend = y.500),
color = "grey",
size = F.df$weight.trans/max.seg.wt*15,
alpha = 0.75) +
new_theme_empty +
geom_point(data = filter(F.nodes, y > 1), aes(x = x, y = y, fill = vertex.names),
shape = 25, size = 30) +
geom_point(data = filter(F.nodes, y == 1), aes(x = x, y = y, fill = vertex.names),
shape = 21, size = 30) +
scale_fill_manual(values = F.nodes$colrs, guide = "none")
F.plot <- ggplot(F.df) +
geom_segment(data = F.df, aes(x = x.1, xend = x.500, y = y.1, yend = y.500),
color = "grey",
size = F.df$weight.trans/max.seg.wt*15,
alpha = 0.75) +
new_theme_empty +
geom_point(data = filter(F.nodes, y > 1), aes(x = x, y = y, fill = vertex.names),
shape = 25, size = 30) +
geom_point(data = filter(F.nodes, y == 1), aes(x = x, y = y, fill = vertex.names),
shape = 21, size = 30) +
scale_fill_manual(values = F.nodes$colrs, guide = "none")
F.plot
F.plot
gtF <- ggplot_gtable(ggplot_build(F.plot))
gtF$layout$clip[gtF$layout$name == "panel"] <- "off"
grid.draw(gtF)
tree_net_vis
P_info <- bipartite_plot_info(web = tree_net_vis$P, order.type = "normal")
P.df <- P_info[[1]] %>%
filter(Sequence == 500 | Sequence == 1) %>%
reshape(idvar = "Group", timevar = "Sequence", direction = "wide") %>%
mutate(weight.trans = Weight.1) # unscaled weights
P_info[[2]]
P.nodes <- P_info[[2]] %>%
mutate(colrs = c(iteo.col, platy.col)) %>%
arrange(vertex.names)
P.nodes
P_info <- bipartite_plot_info(web = tree_net_vis$P, order.type = "normal")
P.df <- P_info[[1]] %>%
filter(Sequence == 500 | Sequence == 1) %>%
reshape(idvar = "Group", timevar = "Sequence", direction = "wide") %>%
mutate(weight.trans = Weight.1) # unscaled weights
P.nodes <- P_info[[2]] %>%
mutate(colrs = c(iteo.col, platy.col)) %>%
arrange(vertex.names)
P.plot <- ggplot(P.df) +
geom_segment(data = P.df, aes(x = x.1, xend = x.500, y = y.1, yend = y.500),
color = "grey",
size = P.df$weight.trans/max.seg.wt*15,
alpha = 0.75) +
new_theme_empty +
geom_point(data = filter(P.nodes, y > 1), aes(x = x, y = y, fill = vertex.names),
shape = 25, size = 30) +
geom_point(data = filter(P.nodes, y == 1), aes(x = x, y = y, fill = vertex.names),
shape = 21, size = 30) +
scale_fill_manual(values = P.nodes$colrs, guide = "none")
P.plot
gtP <- ggplot_gtable(ggplot_build(P.plot))
gtP$layout$clip[gtP$layout$name == "panel"] <- "off"
grid.draw(gtP)
## This R script organizes the data for gall-parasitoid networks on individual trees of different willow genotypes.
## Author: Matt Barbour
## Email: barbour@zoology.ubc.ca
## upload packages for data manipulation. order of libraries is important. always load dplyr last.
library(reshape2)
library(reshape)
library(plyr)
library(dplyr)
## upload molten gall network data and calculate some basic summary data
gall_net_melt <- read.csv("~/Documents/Genotype_Networks/data/gall_network_data.csv")
gall_net_melt <- tbl_df(gall_net_melt) # 1,495 galls
sum(gall_net_melt$value, na.rm = TRUE) # 1709 total samples
sum(filter(gall_net_melt, gall_contents == "nothing")$value) # 518 "nothing" samples
sum(filter(gall_net_melt, gall_contents == "exit.hole")$value) # 136 exit holes. These indicate ectoparasitism, but I was unable to reliably determine attack by the particular parasitoid.
## create a data frame for the estimated number of shoots surveyed on each willow.
shootEsts_df <- gall_net_melt %>%
mutate(plant.position = as.factor(plant.position)) %>%
group_by(Gender, Genotype, plant.position) %>%
summarise(shootEst.no18 = mean(shootEst.no18), shootEst.all = mean(shootEst.all), galls.found = mean(Galls.found)) # needed to take the mean because these shoot estimates are duplicated throughout the molten dataframe
shootEsts_df <- mutate(shootEsts_df, plant.position = as.character(plant.position))
## create a shoot data frame resolved for each genotype. May not need this later
#shootEsts_genotype_df <- shootEsts_df %>%
# group_by(Genotype) %>%
#summarise(n = n(), shootEst.no18 = sum(shootEst.no18), shootEst.all = sum(shootEst.all))
## create the tree-level interaction data
tree_interaxns_filter <- gall_net_melt %>%
filter(gall_contents %in% c("aSG.larv", "Pont.ad", "Pont.prep", "rG.larv", "SG.larv", "vLG.pupa", "Eulo.fem", "Eulo.mal", "Eury.fem", "Eury.mal", "Lathro.fem", "Lathro.mal", "Lestodip", "Mesopol", "Mymarid", "Platy", "Ptero.2", "Tory.fem", "Tory.mal")) # 747 galls. I'm only retaining gall contents for which we could reliably determine the source of mortality or survival.
sum(tree_interaxns_filter$value) # 973 individuals collected from these galls.
tree_interaxns_filter_add <- mutate(tree_interaxns_filter,
gall_contents_collapse = revalue(gall_contents,
c("Pont.ad" = "Pont.surv",
"Pont.prep" = "Pont.surv",
"Eulo.fem" = "Eulo",
"Eulo.mal" = "Eulo",
"Eury.fem" = "Eury",
"Eury.mal" = "Eury",
"Lathro.fem" = "Lathro",
"Lathro.mal" = "Lathro",
"Ptero.2" = "Mesopol",
"Tory.fem" = "Tory",
"Tory.mal" = "Tory") )) # this collapses the different parasitoid sexes into the same species. I also consider seeing Pontania adult and Pontania prepupa as survival.
##### The code below organizes the molten gall network data into a data frame with each plant as a replicate and is therefore the most straightforward for most analyses.
tree_level_interaxn_df <- dcast(tree_interaxns_filter_add,
Gender + Genotype + plant.position ~ gall.sp + gall_contents_collapse,
sum) # reshape the data into a data frame for analysis
tree_level_interaxn_df_add <- mutate(tree_level_interaxn_df,
plant.position = as.character(plant.position),
aSG_abund = rowSums(select(tree_level_interaxn_df,
starts_with("aSG"))),
rG_abund = rowSums(select(tree_level_interaxn_df,
starts_with("rG"))),
vLG_abund = rowSums(select(tree_level_interaxn_df,
starts_with("vLG"))),
SG_abund = rowSums(select(tree_level_interaxn_df,
starts_with("SG"))),
rsLG_abund = rowSums(select(tree_level_interaxn_df,
starts_with("rsLG"))),
Platy_abund = rowSums(select(tree_level_interaxn_df,
ends_with("Platy"))),
Tory_abund =  rowSums(select(tree_level_interaxn_df,
ends_with("Tory"))),
Mesopol_abund =  rowSums(select(tree_level_interaxn_df,
ends_with("Mesopol"))),
Eulo_abund = rowSums(select(tree_level_interaxn_df,
ends_with("Eulo"))),
Lestodip_abund = rG_Lestodip,
Eury_abund = rsLG_Eury,
Lathro_abund = rsLG_Lathro,
Mymarid_abund = vLG_Mymarid,
gall_total_abund = aSG_abund + rG_abund + vLG_abund + SG_abund + rsLG_abund) # adding new columns of total abundance to the data frame.
## had to add these separately because rowSums(select()) wasn't working correctly with different sequences of columns to combine.
tree_level_interaxn_df_add$link_abund <- rowSums(select(tree_level_interaxn_df,
aSG_Tory:rG_Platy, rG_Tory:rsLG_Lathro,
SG_Platy, vLG_Eulo:vLG_Tory)) # same as parasitoid abundance, but wrote this way to maintain consistency with how richness is calculated.
tree_level_interaxn_df_add$link_richness <- rowSums(select(tree_level_interaxn_df_add,
aSG_Tory:rG_Platy, rG_Tory:rsLG_Lathro,
SG_Platy, vLG_Eulo:vLG_Tory) > 0)
tree_level_interaxn_df_add$gall_total_rich <- rowSums(select(tree_level_interaxn_df_add,
aSG_abund:rsLG_abund) > 0)
tree_level_interaxn_df_add$ptoid_total_rich <- rowSums(select(tree_level_interaxn_df_add,
Platy_abund:Mymarid_abund) > 0)
tree_level_interaxn_df_add <- mutate(tree_level_interaxn_df_add,
network_richness = gall_total_rich + ptoid_total_rich,
#gall_survive_abund = aSG_aSG.larv + rG_rG.larv +
#rsLG_Pont.surv + SG_SG.larv + vLG_vLG.pupa, # not clear why I would need this
vLG_parasitized = vLG_Eulo + vLG_Mesopol +
vLG_Mymarid + vLG_Platy + vLG_Tory,
rG_parasitized = rG_Eulo + rG_Lestodip + rG_Mesopol + rG_Platy + rG_Tory,
rsLG_parasitized = rsLG_Lathro + rsLG_Eury,
SG_parasitized = SG_Platy,
aSG_parasitized = aSG_Tory,
vLG_ecto = vLG_Eulo + vLG_Tory + vLG_Mesopol,
rG_ecto = rG_Eulo + rG_Tory + rG_Mesopol,
vLG_egg = vLG_Platy + vLG_Mymarid)
## join the tree level interaction data with the estimated number of shoots sampled per tree.
tree_level_interaxn_df_joined <- left_join(shootEsts_df, tree_level_interaxn_df_add)
length(table(gall_net_melt$plant.position)) # double checked and the number of unique plant positions is preserved
## fill NAs with zeros that are biologically meaningful, since these trees were sampled but no galls were ever collected from them.
tree_level_NAs_to_fill <- tree_level_interaxn_df_joined %>%
ungroup() %>%
select(-(Gender:galls.found)) %>%
as.matrix
tree_level_NAs_to_fill[is.na(tree_level_NAs_to_fill)] <- 0
tree_level_interaxn_all_plants <- cbind.data.frame(select(tree_level_interaxn_df_joined,
Gender:galls.found), tree_level_NAs_to_fill)
tree_level_interaxn_all_plants <- tbl_df(tree_level_interaxn_all_plants)
#tree_level_interaxn_all_plants <- mutate(tree_level_interaxn_all_plants,
#                                        gall_total_densityNO18 = gall_total_abund/shootEst.no18,
#                                       gall_total_densityALL = gall_total_abund/shootEst.no18)
## load plant trait data and gall data from 2011. Consider downloading the data straight from dryad once the repository becomes open.
tree_level_traits <- read.csv("~/Documents/Genotype_Networks/data/plant.trait.galls.2011.tree.df.csv")
tree_level_traits <- select(tree_level_traits, -X, Genotype, plant.position, vLG.2011 = vLG, rsLG.2011 = rsLG, Total_Area:flavanonOLES.PC1)
tree_level_traits$plant.position <- factor(tree_level_traits$plant.position)
## manage gall trait data. The code below resolves everything down to the gall level and not the larva level, since there may be multiple larva within a gall.
gall.size.df <- tree_interaxns_filter_add %>%
group_by(Genotype, plant.position, gall.id.nest, gall.sp) %>% # this makes sure I don't double count galls with multiple larvae, and is also why I take the "average" below, which is just the same number.
summarise(gall.height = mean(g.height))
#gall.contents.df <- tree_interaxns_filter_add %>%
# dcast(gall.id.nest + gall.sp ~ gall_contents_collapse, sum) %>%
#tbl_df()
#gall.size.contents.df <- left_join(gall.size.df, gall.contents.df)
## this data frame resolves everything to gall size at the tree level.
tree_level_gall.size.df <- gall.size.df %>% # gall.size.contents.df
group_by(Genotype, plant.position, gall.sp) %>%
summarise(gall.height.mean = mean(gall.height, na.rm = TRUE), gall.count = n())
## cast the data frame so each row is a unique plant position.
tree_level_gall.size.cast <- dcast(tree_level_gall.size.df, Genotype + plant.position ~ gall.sp,
value.var = "gall.height.mean") %>%
select(Genotype, plant.position,
aSG.height.mean = aSG, rG.height.mean = rG, rsLG.height.mean = rsLG,
SG.height.mean = SG, vLG.height.mean = vLG) %>%
tbl_df()
## same as above but retaining data fro gall count per tree, which is relevant in estimating the accuracy of each mean estimate.
tree_level_gall.count.cast <- dcast(tree_level_gall.size.df, Genotype + plant.position ~ gall.sp,
value.var = "gall.count") %>%
select(Genotype, plant.position,
aSG.gall.count = aSG, rG.gall.count = rG, rsLG.gall.count = rsLG,
SG.gall.count = SG, vLG.gall.count = vLG) %>%
tbl_df()
tree_level_gall.size.count.join <- left_join(tree_level_gall.size.cast, tree_level_gall.count.cast)
## merge interaction and tree-trait data
tree_level_interaxn_all_plants_traits_size <- join_all(list(tree_level_interaxn_all_plants, tree_level_traits, tree_level_gall.size.count.join), by = "plant.position") %>%
tbl_df()
write.csv(tree_level_interaxn_all_plants_traits_size, '~/Documents/Genotype_Networks/data/tree_level_interaxn_all_plants_traits_size.csv')
## for reference in analyses
interaxns_gallsurv <- tree_level_interaxn_all_plants_traits_size %>%
select(aSG_aSG.larv:vLG_vLG.pupa) %>%
names()
interaxns_gallsurv_noPont <- tree_level_interaxn_all_plants_traits_size %>%
select(aSG_aSG.larv:rG_Tory, SG_Platy:vLG_vLG.pupa) %>%
names()
interaxns <- tree_level_interaxn_all_plants_traits_size %>%
select(aSG_Tory:rG_Platy, rG_Tory:rsLG_Lathro, SG_Platy, vLG_Eulo:vLG_Tory) %>%
names()
interaxns_noPont <- tree_level_interaxn_all_plants_traits_size %>%
select(aSG_Tory:rG_Platy, rG_Tory, SG_Platy, vLG_Eulo:vLG_Tory) %>%
names()
tree_level_interaxn_all_plants_traits_size
interaxns_guild <- tree_level_interaxn_all_plants_traits_size %>%
select(aSG_Tory, rG_ecto, rG_Lestodip, vLG_ecto, vLG_egg, SG_Platy) %>%
names()
net_df <- tree_level_interaxn_all_plants_traits_size#filter(tree_level_interaxn_all_plants_traits_size, abund_interaxns_noPont > 0, Genotype %in% geno_3plus)
guild_adonis <- adonis(sqrt(net_df[ ,interaxns_guild]/shootEst.no18) ~ Genotype,
data = net_df,
#strata = net_df$Genotype,
method = "euclidean")
# NOTE THAT I HAVE NOT PERFORMED THESE ANALYSES AFTER REMOVING PP 373 (GENOTYPE S: OUTLYING DATAPOINT FOR VLG AND RG)
## upload source code for managing network data at the tree-level
source('~/Documents/Genotype_Networks/Rscripts/network_management_tree_level.R')
## upload source code for analyzing beta-diversity of interaction networks. Note that this code is necessary for partitioning the components of network beta-diversity, but unnecessary for calculating the total dissimilarity of interaction networks (species turnover + interaction turnover)
source('~/Documents/betalink/R/betalink.R')
source('~/Documents/betalink/R/vec2data.frame.R')
source('~/Documents/betalink/R/measures.r')
source('~/Documents/betalink/R/betalink.b.r')
source('~/Documents/betalink/R/betalink.dist.r')
source('~/Documents/betalink/R/betalink.q.R')
## upload required libraries for analysis
library(vegan)
## main dataset is 'tree_level_interaxn_all_plants'
#### Analysis of dissimilarity of gall-parasitoid interaction networks among genotypes
abund_interaxns_gallsurv_noPont <- rowSums(tree_level_interaxn_all_plants_traits_size[ ,interaxns_gallsurv_noPont]
abund_interaxns_noPont <- rowSums(tree_level_interaxn_all_plants_traits_size[ ,interaxns_noPont])
table(filter(tree_level_interaxn_all_plants_traits_size, abund_interaxns_noPont > 0)$Genotype)
## when 'net_df <- filter(tree_level_interaxn_all_plants_traits_size, abund_interaxns_noPont > 0'. The replicate samples of many of the Genotypes is reduced to a very low level. To see whether removing these genotypes affects the outcome of the analysis, I have created the following subsets.
geno_2plus <- c("*","A","B","D","E","F","I","K","L","Q","S","T","V","W","X","Y","Z") # 17
geno_3plus <- c("*","B","D","I","K","L","Q","S","V","W","X","Y","Z") # 13
geno_4plus <- c("*","B","I","K","L","S","V","X","Z") # 9 (if Pontania galls were included, then I would have retained Genotype D as well.)
## dataset to use for PERMANOVA
net_df <- tree_level_interaxn_all_plants_traits_size#filter(tree_level_interaxn_all_plants_traits_size, abund_interaxns_noPont > 0, Genotype %in% geno_3plus)
## Permutational multivariate analysis of variance (PERMANOVA)
net_qual <- ifelse(net_df[ ,interaxns_noPont] > 0, 1, 0)
guild_adonis <- adonis(sqrt(net_df[ ,interaxns_guild]/shootEst.no18) ~ Genotype,
data = net_df,
#strata = net_df$Genotype,
method = "euclidean")
guild_adonis
plot(rda(sqrt(net_df[ ,interaxns_guild]/net_df$shootEst.no18) ~ Genotype, data = net_df), display = c("sp"), scaling = 2) # look at relationships among species. In line with what I expected. All of the ectoparasitoids are aligned on the same axis.
colSums(net_df[ ,interaxns_guild])
colSums(net_df[ ,interaxns_guild])[c(2,4,5)]
sum(colSums(net_df[ ,interaxns_guild])[c(2,4,5)])/colSums(net_df[ ,interaxns_guild])
sum(colSums(net_df[ ,interaxns_guild])[c(2,4,5)])/sum(colSums(net_df[ ,interaxns_guild]))
mean(table(net_df$Genotype))
guild_adonis
guild.adonis.ss <- mean(table(net_df$Genotype)) # 5.6 average sample size for genotypes
guild.gen.ms <- guild_adonis$aov.tab$MeanSqs[1]
guild.res.ms <- guild_adonis$aov.tab$MeanSqs[2] # also equal to residual variance
guild.gen.var <- (guild.gen.ms - guild.res.ms)/guild.adonis.ss
guild.h2 <- guild.gen.var/(guild.gen.var + guild.res.ms)
guild.h2
