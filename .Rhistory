## perform RDA analyses and extract centroid scores for plotting.
cap.geno <- capscale(full.links.df.sub[ ,all.links] ~ Genotype,
data = full.links.df.sub,
distance = "bray")
summary(cap.geno)
centroids.cap.geno <- data.frame(scores(cap.geno, choices = c(1,2), display = "cn"))
rownames(centroids.cap.geno) <- levels(full.links.df$Genotype)[-c(10,14,21)] # remove Genotypes J, N, and U
centroids.cap.geno$Genotype <- rownames(centroids.cap.geno)
sites.cap.geno <- data.frame(scores(cap.geno, choices = c(1,2), display = "sites"), droplevels(full.links.df.sub$Genotype))
colnames(sites.cap.geno)[3] <- "Genotype"
plot.new() # need to call this for ordiellipse function to work
ellip <- ordiellipse(cap.geno, groups = full.links.df.sub$Genotype,
kind = "se", draw = "polygon", #Note that by specificying the kind of ellipse in ordiellipse will make sure the type of ellipse you want is drawn (e.g. standard error or 95% CI)
col= "gray50", #"gainsboro",
border = NA, label = T)
## ggplot2 ordination plot ----
# function for ellipses: taken from the excellent stackoverflow Q+A: http://stackoverflow.com/questions/13794419/plotting-ordiellipse-function-from-vegan-package-onto-nmds-plot-created-in-ggplot2. Another useful reference was https://oliviarata.wordpress.com/2014/04/17/ordinations-in-ggplot2/
veganCovEllipse <- function (cov, center = c(0, 0), scale = 1, npoints = 100)
{
theta <- (0:npoints) * 2 * pi/npoints
Circle <- cbind(cos(theta), sin(theta))
t(center + scale * t(Circle %*% chol(cov)))
}
# data for ellipse.
df_ell.cap.geno <- data.frame() #sets up a data frame before running the function.
for(g in levels(sites.cap.geno$Genotype)){
df_ell.cap.geno <- rbind(df_ell.cap.geno,
cbind(as.data.frame(
with(sites.cap.geno[sites.cap.geno$Genotype == g, ],
veganCovEllipse(ellip[[g]]$cov, ellip[[g]]$center, ellip[[g]]$scale))), Genotype = g))
}
#B.compliment <- data.frame(x = -2.925, y = 2.4, labels = "(B)") # plot label
compliment <- ggplot(data = df_ell.cap.geno, aes(x = CAP1, y = CAP2, group = Genotype)) +
coord_fixed(ratio = 1) + #, xlim= c(-3.3,3.3)) + #xlim = c(-3,3.2)
geom_polygon(color = NA, fill = "gray50", alpha = 0.5) + # didn't use stat_ellipse because I wanted to plot standard errors instead of 95% confidence intervals
geom_text(data = centroids.cap.geno,
aes(x = CAP1, y = CAP2, label = Genotype), size = 2) +
#scale_x_continuous(limits = c(-3,2)) +
#geom_text(data = B.compliment, aes(x = x, y = y, label = labels),
#          inherit.aes = FALSE, size = 4) +
theme_bw() +
theme(axis.text.y = element_text(size = 6),#10
axis.text.x = element_text(size = 6),#10
axis.title.x = element_text(size = 8, vjust = 0.75),#vjust = 0.1,
axis.title.y = element_text(size = 8, vjust = 0.25),#vjust = 0.5,
panel.grid = element_blank(),
plot.margin = unit(c(0,0,0,0), "in"))
# adjust plot.margin
vp <- viewport(width = 0.35, height = 0.35, x = 0.75, y = 0.32) #viewport(width = 0.4, height = 0.4, x = 0.7, y = 0.35)
tiff("~/Documents/Genotype_Networks/figures/fig_6_complexity_complimentarity.tif", width = 3.42, height = 4, units = "in", res = 600)
print(total)
print(compliment, vp = vp)
dev.off() # turn off png device
install.packages(c("gridExtra","vegan"))
install.packages(c("gridExtra", "vegan"))
require(ggplot2)
#devtools::install_github("hadley/ggplot2")
require(gridExtra)
require(dplyr)
require(tidyr)
require(vegan)
## tidy up full link composition data for ordination of entire food web ----
full.links.df <- as.data.frame(tree_level_interaxn_all_plants_traits_size) %>%
select(Genotype,
vLG_abund, aSG_abund, rG_abund, SG_abund, # willow-gall links
vLG_Platy, vLG_Tory, vLG_Mesopol, vLG_Eulo, vLG_Mymarid, # vLG-ptoid links
rG_Platy, rG_Tory, rG_Mesopol, rG_Eulo, rG_Lestodip, # rG-ptoid links
SG_Platy, aSG_Tory) # other gall-ptoid links
all.links <- names(full.links.df)[-1]
trees.with.links <- which(rowSums(full.links.df[ ,all.links]) > 0)
table(full.links.df$Genotype[trees.with.links]) # J, N, and U have 2 or less replicates with any links.
full.links.df.sub <- filter(full.links.df[trees.with.links, ],
Genotype != "J",
Genotype != "N",
Genotype != "U")
## analysis of dissimilarity
adonis(full.links.df.sub[ ,all.links] ~ Genotype, data = full.links.df.sub, distance = "bray")
anova(betadisper(vegdist(full.links.df.sub[ ,all.links], "bray"), full.links.df.sub$Genotype)) # no difference in betadiversity
full.links.meandist <- meandist(vegdist(full.links.df.sub[ ,all.links], "bray"), full.links.df.sub$Genotype)
summary(full.links.meandist)
mean(full.links.meandist[lower.tri(full.links.meandist, diag = TRUE)]) # eseentially matches summary, may be slightly different due to weightings.
max(full.links.meandist[lower.tri(full.links.meandist, diag = TRUE)])
min(full.links.meandist[lower.tri(full.links.meandist, diag = TRUE)])
## perform RDA analyses and extract centroid scores for plotting.
cap.geno <- capscale(full.links.df.sub[ ,all.links] ~ Genotype,
data = full.links.df.sub,
distance = "bray")
summary(cap.geno)
centroids.cap.geno <- data.frame(scores(cap.geno, choices = c(1,2), display = "cn"))
rownames(centroids.cap.geno) <- levels(full.links.df$Genotype)[-c(10,14,21)] # remove Genotypes J, N, and U
centroids.cap.geno$Genotype <- rownames(centroids.cap.geno)
sites.cap.geno <- data.frame(scores(cap.geno, choices = c(1,2), display = "sites"), droplevels(full.links.df.sub$Genotype))
colnames(sites.cap.geno)[3] <- "Genotype"
plot.new() # need to call this for ordiellipse function to work
ellip <- ordiellipse(cap.geno, groups = full.links.df.sub$Genotype,
kind = "se", draw = "polygon", #Note that by specificying the kind of ellipse in ordiellipse will make sure the type of ellipse you want is drawn (e.g. standard error or 95% CI)
col= "gray50", #"gainsboro",
border = NA, label = T)
## ggplot2 ordination plot ----
# function for ellipses: taken from the excellent stackoverflow Q+A: http://stackoverflow.com/questions/13794419/plotting-ordiellipse-function-from-vegan-package-onto-nmds-plot-created-in-ggplot2. Another useful reference was https://oliviarata.wordpress.com/2014/04/17/ordinations-in-ggplot2/
veganCovEllipse <- function (cov, center = c(0, 0), scale = 1, npoints = 100)
{
theta <- (0:npoints) * 2 * pi/npoints
Circle <- cbind(cos(theta), sin(theta))
t(center + scale * t(Circle %*% chol(cov)))
}
# data for ellipse.
df_ell.cap.geno <- data.frame() #sets up a data frame before running the function.
for(g in levels(sites.cap.geno$Genotype)){
df_ell.cap.geno <- rbind(df_ell.cap.geno,
cbind(as.data.frame(
with(sites.cap.geno[sites.cap.geno$Genotype == g, ],
veganCovEllipse(ellip[[g]]$cov, ellip[[g]]$center, ellip[[g]]$scale))), Genotype = g))
}
#B.compliment <- data.frame(x = -2.925, y = 2.4, labels = "(B)") # plot label
compliment <- ggplot(data = df_ell.cap.geno, aes(x = CAP1, y = CAP2, group = Genotype)) +
coord_fixed(ratio = 1) + #, xlim= c(-3.3,3.3)) + #xlim = c(-3,3.2)
geom_polygon(color = NA, fill = "gray50", alpha = 0.5) + # didn't use stat_ellipse because I wanted to plot standard errors instead of 95% confidence intervals
geom_text(data = centroids.cap.geno,
aes(x = CAP1, y = CAP2, label = Genotype), size = 2) +
#scale_x_continuous(limits = c(-3,2)) +
#geom_text(data = B.compliment, aes(x = x, y = y, label = labels),
#          inherit.aes = FALSE, size = 4) +
theme_bw() +
theme(axis.text.y = element_text(size = 6),#10
axis.text.x = element_text(size = 6),#10
axis.title.x = element_text(size = 8, vjust = 0.75),#vjust = 0.1,
axis.title.y = element_text(size = 8, vjust = 0.25),#vjust = 0.5,
panel.grid = element_blank(),
plot.margin = unit(c(0,0,0,0), "in"))
# adjust plot.margin
vp <- viewport(width = 0.35, height = 0.35, x = 0.75, y = 0.32) #viewport(width = 0.4, height = 0.4, x = 0.7, y = 0.35)
tiff("~/Documents/Genotype_Networks/figures/fig_6_complexity_complimentarity.tif", width = 3.42, height = 4, units = "in", res = 600)
print(total)
print(compliment, vp = vp)
dev.off() # turn o
vp <- viewport(width = 0.35, height = 0.35, x = 0.75, y = 0.32) #viewport(width = 0.4, height = 0.4, x = 0.7, y = 0.35)
tiff("~/Documents/Genotype_Networks/figures/fig_6_complexity_complimentarity.tiff", width = 3.42, height = 4, units = "in", res = 600)
print(total)
print(compliment, vp = vp)
dev.off() # turn off png device
web complexity (weighted linkage density)
total.labels <- paste(c(" ",1,5,10,15,20,25),
c("(1) "," (4)","(20)","(40)","(60)","(80)","(100)"), sep = "\n")
total <- ggplot(web.measures.summary,#all.measures,
aes(x = genotypes.sampled,
y = mean.complexity,# total_complexity,
group = genotypes.sampled)) +
#stat_summary(fun.y = mean, geom = "point", color = "grey",
#            shape = 1, size = 1.5) +
geom_jitter(color = "grey", shape = 1, position = position_jitter(width = 0.25, height = NULL), size = 1) +
stat_summary(fun.y = mean, geom = "point", color = "steelblue",
shape = 20, size = 3) +
#geom_line(data = full.nls.predict.df, aes(x = genotypes.sampled, y = mean.complexity),
# size = 1,
# color = "steelblue", inherit.aes = FALSE) +
#geom_boxplot(aes(group = genotypes.sampled),
#           notch = TRUE, outlier.shape = 1,
#          outlier.colour = "grey", fill = "steelblue") +
#geom_jitter(shape = 1,
#           color = "grey",
#          position = position_jitter(width = 0.25, height = NULL),
#         size = 1) +
#stat_summary(fun.y = mean, geom = "point", color = "steelblue", size = 3) +
#geom_boxplot(data = monos.summary,
#          aes(x = plants.sampled/4,
#             y = total_complexity.mean,
#            group = plants.sampled),
#       color = "black",
#      outlier.shape = NA,
#outlier.colour = "black",
#     inherit.aes = FALSE) +
geom_point(data = monos.summary.plot,
aes(x = plants.sampled/4,
y = total_complexity.mean),
color = "black", size = 1.5,
inherit.aes = FALSE) +
geom_line(data = monos.nls.predict,
aes(x = plants.sampled/4, y = total_complexity),
linetype = "dashed",
color = "black",
inherit.aes = FALSE) +
xlab("No. of willow genotypes (no. of plants)") +
ylab(bquote('Food-web complexity ('*italic(LD[q])*')')) +
scale_x_continuous(limits = c(0.1,25.5),
breaks = c(0.25,1,5,10,15,20,25),
labels = total.labels) +
scale_y_continuous(limits = c(1,2.45), #c(1,2.4)
breaks = seq(1, 2.25, by = 0.25)) +
theme_bw() +
theme(axis.text.y = element_text(size = 9),
axis.text.x = element_text(size = 6),#9
axis.title.x = element_text(size = 11, vjust = 0.1),
axis.title.y = element_text(size = 11, vjust = 0.5),
panel.grid = element_blank())
total
vp <- viewport(width = 0.35, height = 0.35, x = 0.75, y = 0.32) #viewport(width = 0.4, height = 0.4, x = 0.7, y = 0.35)
tiff("~/Documents/Genotype_Networks/figures/fig_6_complexity_complimentarity.tiff", width = 3.42, height = 4, units = "in", res = 600)
print(total)
print(compliment, vp = vp)
dev.off() # turn off png device
dim(all.measures)[1] # 216,102 unique simulations. 250,00 simulations originally run
source('Rscripts/fxns_mvabund_diagnostics.R')
poisson_curve()
source('~/Documents/Genotype_Networks/Rscripts/network_management_tree_level.R')
source('~/Documents/Genotype_Networks/Rscripts/network_management_tree_level.R')
tree_level_interaxn_all_plants_traits_size
## load required libraries ----
library(vegan) # for adonis analysis
#library(knitr) # for making tables
#library(ggplot2) # for plotting
#theme_set(theme_bw()) # customize ggplot for prettier default graphs
#library(gridExtra) # for grid.arrange
library(mvabund) # multivariate analysis
library(HH) # for variance inflation factor analysis (vif) in multiple regression
library(visreg) # visualize regression output
library(dplyr) # for dataset
## create datasets for analysis ----
full.df <- read.csv('data/tree_level_interaxn_all_plants_traits_size.csv') %>% tbl_df()
interaxns_noPont <- full.df %>%
select(aSG_Tory:rG_Platy, rG_Tory, SG_Platy, vLG_Eulo:vLG_Tory) %>%
names()
install.packages("HH")
full.df <- read.csv('data/tree_level_interaxn_all_plants_traits_size.csv') %>% tbl_df()
interaxns_noPont <- full.df %>%
select(aSG_Tory:rG_Platy, rG_Tory, SG_Platy, vLG_Eulo:vLG_Tory) %>%
names()
interaxns_noPont
## exploratory plots
vLG.height.mean.plot <- ggplot(data = full.df, aes(x = Genotype, y = vLG.height.mean)) +
geom_boxplot() + ylab("Iteomyia salicisverruca diameter (mm)")
rG.height.mean.plot <- ggplot(data = full.df, aes(x = Genotype, y = rG.height.mean)) +
geom_boxplot() + ylab("Rabdophaga salicisbrassicoides diameter (mm)")
aSG.height.mean.plot <- ggplot(data = full.df, aes(x = Genotype, y = aSG.height.mean)) +
geom_boxplot() + ylab("Cecidomyid sp. A diameter (mm)")
SG.height.mean.plot <- ggplot(data = full.df, aes(x = Genotype, y = SG.height.mean)) +
geom_boxplot() + ylab("Rabdophaga salicisbattatus diameter (mm)")
grid.arrange(vLG.height.mean.plot, rG.height.mean.plot, aSG.height.mean.plot, SG.height.mean.plot)
library(ggplot2) # for exploratory plots
theme_set(theme_bw()) # customize ggplot for prettier default graphs
library(gridExtra)
vLG.height.mean.plot <- ggplot(data = full.df, aes(x = Genotype, y = vLG.height.mean)) +
geom_boxplot() + ylab("Iteomyia salicisverruca diameter (mm)")
rG.height.mean.plot <- ggplot(data = full.df, aes(x = Genotype, y = rG.height.mean)) +
geom_boxplot() + ylab("Rabdophaga salicisbrassicoides diameter (mm)")
aSG.height.mean.plot <- ggplot(data = full.df, aes(x = Genotype, y = aSG.height.mean)) +
geom_boxplot() + ylab("Cecidomyid sp. A diameter (mm)")
SG.height.mean.plot <- ggplot(data = full.df, aes(x = Genotype, y = SG.height.mean)) +
geom_boxplot() + ylab("Rabdophaga salicisbattatus diameter (mm)")
grid.arrange(vLG.height.mean.plot, rG.height.mean.plot, aSG.height.mean.plot, SG.height.mean.plot)
# We used multivariate GLMs to examine whether gall abundances varied among willow genotypes.
# Boxplots of gall abundance among the different genotypes.
gall.plot.df <- as.data.frame(full.df) %>% # melt doesn't like 'tbl' class
select(Genotype,
Iteomyia_salicisverruca = vLG_abund,
Cecidomyiid_sp.A = aSG_abund,
Rabdophaga_salicisbrassicoides = rG_abund,
Rabdophaga_salicisbattatus = SG_abund) %>%
melt()
ggplot(gall.plot.df, aes(x = Genotype, y = value, color = variable)) +
geom_boxplot() + facet_wrap( ~ variable, nrow = 2) + theme_bw() + ylab("Gall density (no. per branch)")
gall.mvabund <- mvabund(full.df[ ,c("vLG_abund","rG_abund","aSG_abund","SG_abund")])
meanvar.plot(gall.mvabund ~ full.df$Genotype)
poisson_curve(from = 0.1, to = 10)
quasipoisson_curve(from = 0.1, to = 10, quasi.scalar = 2)
neg.binomial_curve(from = 0.1, to = 10, theta.negbin = 0.7) # negative binomial
gall.mvabund <- mvabund(full.df[ ,c("vLG_abund","rG_abund","aSG_abund","SG_abund")])
meanvar.plot(gall.mvabund ~ full.df$Genotype)
poisson_curve(from = 0.1, to = 10)
quasipoisson_curve(from = 0.1, to = 10, quasi.scalar = 2)
neg.binomial_curve(from = 0.1, to = 10, theta.negbin = 0.7) # negative binomial
manyglm.gall <- manyglm(gall.mvabund ~ Genotype,
data = full.df,
family = "negative.binomial")
## examine residual plots of the model.
plot(manyglm.gall, which = 1:3)
anova.gall <- anova.manyglm(manyglm.gall, p.uni = "unadjusted")
anova.gall
gall.comm <- full.df %>% select(Genotype, vLG_abund, rG_abund, aSG_abund, SG_abund)
gall.comm.sub <- filter(gall.comm, rowSums(gall.comm[ ,-1]) > 0,
Genotype != "J", Genotype != "N", Genotype != "U")
table(gall.comm.sub$Genotype) # restricted to Genotypes with greater than 2 replicates for composition analyses.
bray.gall.comm.sub <- vegdist(gall.comm.sub[ ,-1], method = "bray")
adonis(bray.gall.comm.sub ~ Genotype, data = gall.comm.sub)
anova(betadisper(bray.gall.comm.sub, group = gall.comm.sub$Genotype)) # no differences in dispersion among willow genotypes.
summary(meandist(bray.gall.comm.sub, grouping = gall.comm.sub$Genotype))
# subset the final trait-gall datasets
galls_galls.traits <- mvabund(select(gall.density.df, aSG_abund:SG_abund))
traits_galls.traits <- select(gall.density.df, C_N_imputed, water_content, sal_tannin.PC1:SLA_resid)
# specificy the multivariate GLM
mvabund.galls.traits <- manyglm(galls_galls.traits ~ C_N_imputed + water_content + sal_tannin.PC1 + cinn.PC1 + cinn.PC2 + flavonOLES.PC1 + flavonOLES.PC2 + flavanonOLES.PC1 + log_size + log_trichomes + Height_resid + Density_resid + SLA_resid,
data = traits_galls.traits,
family = "negative.binomial")
# plot residuals to assess model fit
plot(mvabund.galls.traits, which = 1:3)
# Starting with the most complex model, we progressively dropped predictors from the model that resulted in the lowest AIC for the model. We continued this in stepwise fashion until we arrived at the null model (no predictors). Using AIC and likelihood ratio tests, we found that four of these models provided a better fit to the data than the null model. For clarity, we only interpret model 11 as this one had the second to lowest AIC value, yet likelihood ratio tests suggested that it provided a significantly better fit than the alternative models.
## drop variables that reduce AIC the most and remove them in a stepwise fashion from analysis.
drop1(mvabund.galls.traits)
mod2 <- update(mvabund.galls.traits, .~. - sal_tannin.PC1); drop1(mod2)
mod3 <- update(mod2, .~. - flavonOLES.PC1); drop1(mod3)
mod4 <- update(mod3, .~. -water_content); drop1(mod4)
mod5 <- update(mod4, .~. - cinn.PC2); drop1(mod5)
mod6 <- update(mod5, .~. - cinn.PC1); drop1(mod6)
mod7 <- update(mod6, .~. -SLA_resid); drop1(mod7)
mod8 <- update(mod7, .~. -Height_resid); drop1(mod8)
mod9 <- update(mod8, .~. -Density_resid); drop1(mod9)
mod10 <- update(mod9, .~. -flavonOLES.PC2); drop1(mod10)
mod11 <- update(mod10, .~. -log_trichomes); drop1(mod11)
mod12 <- update(mod11, .~. -C_N_imputed); drop1(mod12)
mod13 <- update(mod12, .~. -log_size); drop1(mod13)
mod14.null <- update(mod13, .~. -flavanonOLES.PC1)
## use AIC to compare models
AIC.models.galls.traits <- data.frame(Model = 1:14, # progressive order in which models were fit
Formula = c(paste(formula(mvabund.galls.traits)[3]),
paste(formula(mod2)[3]),
paste(formula(mod3)[3]),
paste(formula(mod4)[3]),
paste(formula(mod5)[3]),
paste(formula(mod6)[3]),
paste(formula(mod7)[3]),
paste(formula(mod8)[3]),
paste(formula(mod9)[3]),
paste(formula(mod10)[3]),
paste(formula(mod11)[3]),
paste(formula(mod12)[3]),
paste(formula(mod13)[3]),
paste(formula(mod14.null)[3])),
AIC = c(sum(AIC(mvabund.galls.traits)),
sum(AIC(mod2)),
sum(AIC(mod3)),
sum(AIC(mod4)),
sum(AIC(mod5)),
sum(AIC(mod6)),
sum(AIC(mod7)),
sum(AIC(mod8)),
sum(AIC(mod9)),
sum(AIC(mod10)),
sum(AIC(mod11)),
sum(AIC(mod12)),
sum(AIC(mod13)),
sum(AIC(mod14.null))))
# selects galls and traits for analysis
galls.traits.df <- full.df %>%
select(aSG_abund:SG_abund,
vLG.height.mean, vLG.gall.count,
Trichome.No., Total_Area, Height, Density,
C_N_imputed, water_content, specific_leaf_area, sal_tannin.PC1:flavanonOLES.PC1)
# create dataset of galls and plant traits for analysis
gall.density.df <- galls.traits.df %>%
mutate(log_size = log(Total_Area),
log_trichomes = log(Trichome.No.+1)) %>%
select(aSG_abund:SG_abund, Height:log_trichomes) %>%
na.omit()
# Used sequential regression to reduce multicollinearity among non-principal component traits. For justification, see Graham 2003 (Ecology) and Barbour et al. 2015 (Functional Ecology).
gall.density.df$Height_resid = resid(lm(Height ~ log_size, gall.density.df))
gall.density.df$Density_resid = resid(lm(Density ~ log_size, gall.density.df))
gall.density.df$SLA_resid = resid(lm(specific_leaf_area ~ water_content, gall.density.df))
# subset the final trait-gall datasets
galls_galls.traits <- mvabund(select(gall.density.df, aSG_abund:SG_abund))
traits_galls.traits <- select(gall.density.df, C_N_imputed, water_content, sal_tannin.PC1:SLA_resid)
# specificy the multivariate GLM
mvabund.galls.traits <- manyglm(galls_galls.traits ~ C_N_imputed + water_content + sal_tannin.PC1 + cinn.PC1 + cinn.PC2 + flavonOLES.PC1 + flavonOLES.PC2 + flavanonOLES.PC1 + log_size + log_trichomes + Height_resid + Density_resid + SLA_resid,
data = traits_galls.traits,
family = "negative.binomial")
# plot residuals to assess model fit
plot(mvabund.galls.traits, which = 1:3)
# Starting with the most complex model, we progressively dropped predictors from the model that resulted in the lowest AIC for the model. We continued this in stepwise fashion until we arrived at the null model (no predictors). Using AIC and likelihood ratio tests, we found that four of these models provided a better fit to the data than the null model. For clarity, we only interpret model 11 as this one had the second to lowest AIC value, yet likelihood ratio tests suggested that it provided a significantly better fit than the alternative models.
## drop variables that reduce AIC the most and remove them in a stepwise fashion from analysis.
drop1(mvabund.galls.traits)
mod2 <- update(mvabund.galls.traits, .~. - sal_tannin.PC1); drop1(mod2)
mod3 <- update(mod2, .~. - flavonOLES.PC1); drop1(mod3)
mod4 <- update(mod3, .~. -water_content); drop1(mod4)
mod5 <- update(mod4, .~. - cinn.PC2); drop1(mod5)
mod6 <- update(mod5, .~. - cinn.PC1); drop1(mod6)
mod7 <- update(mod6, .~. -SLA_resid); drop1(mod7)
mod8 <- update(mod7, .~. -Height_resid); drop1(mod8)
mod9 <- update(mod8, .~. -Density_resid); drop1(mod9)
mod10 <- update(mod9, .~. -flavonOLES.PC2); drop1(mod10)
mod11 <- update(mod10, .~. -log_trichomes); drop1(mod11)
mod12 <- update(mod11, .~. -C_N_imputed); drop1(mod12)
mod13 <- update(mod12, .~. -log_size); drop1(mod13)
mod14.null <- update(mod13, .~. -flavanonOLES.PC1)
## use AIC to compare models
AIC.models.galls.traits <- data.frame(Model = 1:14, # progressive order in which models were fit
Formula = c(paste(formula(mvabund.galls.traits)[3]),
paste(formula(mod2)[3]),
paste(formula(mod3)[3]),
paste(formula(mod4)[3]),
paste(formula(mod5)[3]),
paste(formula(mod6)[3]),
paste(formula(mod7)[3]),
paste(formula(mod8)[3]),
paste(formula(mod9)[3]),
paste(formula(mod10)[3]),
paste(formula(mod11)[3]),
paste(formula(mod12)[3]),
paste(formula(mod13)[3]),
paste(formula(mod14.null)[3])),
AIC = c(sum(AIC(mvabund.galls.traits)),
sum(AIC(mod2)),
sum(AIC(mod3)),
sum(AIC(mod4)),
sum(AIC(mod5)),
sum(AIC(mod6)),
sum(AIC(mod7)),
sum(AIC(mod8)),
sum(AIC(mod9)),
sum(AIC(mod10)),
sum(AIC(mod11)),
sum(AIC(mod12)),
sum(AIC(mod13)),
sum(AIC(mod14.null))))
AIC.models.galls.traits
AIC.models.galls.traits
arrange(AIC.models.galls.traits, AIC)[1:5,]
vLG.trait <- MASS::glm.nb(vLG_abund ~ C_N_imputed + log_size + flavanonOLES.PC1, gall.density.df)
summary(vLG.trait)
visreg(vLG.trait, xvar = "C_N_imputed", scale = "response")
visreg(vLG.trait, xvar = "C_N_imputed", scale = "response")
visreg(vLG.trait, xvar = "C_N_imputed", scale = "response")
aSG.trait <- MASS::glm.nb(aSG_abund ~ C_N_imputed + log_size + flavanonOLES.PC1, gall.density.df)
summary(aSG.trait)
visreg(aSG.trait, xvar = "flavanonOLES.PC1", scale = "response") # may or may not be too important
rG.trait <- MASS::glm.nb(rG_abund ~ C_N_imputed + log_size + flavanonOLES.PC1, gall.density.df)
summary(rG.trait)
visreg(rG.trait, xvar = "log_size", scale = "response")
visreg(rG.trait, xvar = "C_N_imputed", scale = "response")
SG.trait <- MASS::glm.nb(SG_abund ~ C_N_imputed + log_size + flavanonOLES.PC1, gall.density.df)
summary(SG.trait) # some warnings about lack of convergence
visreg(SG.trait, xvar = "log_size", scale = "response") # not a great fit. Outlier seems to be driving most of this relationship.
gall.size.df <- galls.traits.df %>%
mutate(log_size = log(Total_Area),
log_trichomes = log(Trichome.No.+1)) %>%
select(vLG.height.mean, vLG.gall.count, Height:log_trichomes) %>%
na.omit()
gall.size.df$Height_resid = resid(lm(Height ~ log_size, gall.size.df))
gall.size.df$Density_resid = resid(lm(Density ~ log_size, gall.size.df))
gall.size.df$SLA_resid = resid(lm(specific_leaf_area ~ water_content, gall.size.df))
gall.size.df <- select(gall.size.df, vLG.height.mean, vLG.gall.count,
C_N_imputed, water_content,
sal_tannin.PC1:SLA_resid)
# specify linear model
vLG.size.lm <- lm(vLG.height.mean ~ ., select(gall.size.df, -vLG.gall.count), weights = gall.size.df$vLG.gall.count)
# reiterate AIC stepwise procedure
drop1(vLG.size.lm)
size2 <- update(vLG.size.lm, .~. -C_N_imputed); drop1(size2)
size3 <- update(size2, .~. -Density_resid); drop1(size3)
size4 <- update(size3, .~. -flavonOLES.PC2); drop1(size4)
size5 <- update(size4, .~. -flavanonOLES.PC1); drop1(size5)
size6 <- update(size5, .~. -log_trichomes); drop1(size6)
size7 <- update(size6, .~. -SLA_resid); drop1(size7)
size8 <- update(size7, .~. -Height_resid); drop1(size8)
size9 <- update(size8, .~. -water_content); drop1(size9)
size10 <- update(size9, .~. -log_size); drop1(size10)
size11 <- update(size10, .~. -cinn.PC1); drop1(size11)
size12 <- update(size11, .~. -cinn.PC2); drop1(size12)
size13 <- update(size12, .~. -flavonOLES.PC1); drop1(size13)
size14.null <- update(size13, .~. -sal_tannin.PC1)
## use AIC to compare models
AIC.vLG.size.traits <- data.frame(Models = 1:14, # progressive order in which size models were fit
Formula = c(paste(formula(vLG.size.lm)[3]),
paste(formula(size2)[3]),
paste(formula(size3)[3]),
paste(formula(size4)[3]),
paste(formula(size5)[3]),
paste(formula(size6)[3]),
paste(formula(size7)[3]),
paste(formula(size8)[3]),
paste(formula(size9)[3]),
paste(formula(size10)[3]),
paste(formula(size11)[3]),
paste(formula(size12)[3]),
paste(formula(size13)[3]),
paste(formula(size14.null)[3])),
AIC = c(sum(AIC(vLG.size.lm)),
sum(AIC(size2)),
sum(AIC(size3)),
sum(AIC(size4)),
sum(AIC(size5)),
sum(AIC(size6)),
sum(AIC(size7)),
sum(AIC(size8)),
sum(AIC(size9)),
sum(AIC(size10)),
sum(AIC(size11)),
sum(AIC(size12)),
sum(AIC(size13)),
sum(AIC(size14.null))))
arrange(AIC.vLG.size.traits, AIC)
summary(size11)
summary(size10)
summary(size12) # final model
summary(size9)
anova(size14.null, size12)
anova(size14.null, size13, size12, size11, size10, size9, size8, size7)
plot(size12) # residuals looks pretty good
vLG.size.predict <- visreg(size12)
max(vLG.size.predict$sal_tannin.PC1$y$fit)/min(vLG.size.predict$sal_tannin.PC1$y$fit)
vLG.size.predict <- visreg(size12)
max(vLG.size.predict$sal_tannin.PC1$y$fit)/min(vLG.size.predict$sal_tannin.PC1$y$fit)
max(vLG.size.predict$flavonOLES.PC1$y$fit)/min(vLG.size.predict$flavonOLES.PC1$y$fit)
full.mvabund <- mvabund(full.df[ ,interaxns_noPont]) # create mvabund object for easy analysis
full.meanvar <- meanvar.plot(full.mvabund ~ full.df$Genotype, table = TRUE) # easy to see that the data do not have a poisson distribution, therefore, a negative binomial may be a good fit.
poisson_curve(from = 0.1, to = 3.0, color = "blue")
quasipoisson_curve(from = 0.1, to = 3.0, quasi.scalar = 2, color = "red")
neg.binomial_curve(from = 0.1, to = 3.0, theta.negbin = 0.7, color = "black") # negative binomial appears to provide the best fit to this relationship
manyglm.full <- manyglm(full.mvabund ~ Genotype,
data = full.df,
family = "negative.binomial")
plot(manyglm.full, which = 1:3)
full.mvabund
plot(manyglm.full, which = 1:3) # residuals aren't quite normally distributed, but there doesn't seem to be any heteroscedasticity in the model fit. Note that replotting the residuals gives qualitatively the same picture (it's important to replot them because the residuals involve random number generation, see ?plot.manyglm)
