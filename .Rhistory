type = "l", ylab="Density", xlab="Time", ylim=c(0, C*15), main = "2 Consumers, 2 Resources", lwd = 3)
legend("top", c("R1","R2", "C1", "C2"), lty=1:4, col=1:4, bty="n", lwd = 3)
# new state variables for model
C2 <- C1
i.state2 <- c(R1 = R1, R2 = R2, C1 = C1, C2 = C2)
# new parameters for model
e2 <- e1
dC2 <- dC1
# run the experiment. This experiment essentially solves the model at the initial C and R densities, and takes the new C and R densities and reruns the model, and so on until the end of time.
p.rm2 <- c(r1 = r1, r2 = r2,
K1 = K1, K2 = K2,
e1 = e1, e2 = e2,
a1 = a1*4, a2 = a2,
h1 = h1/3, h2 = h2,
dC1 = dC1, dC1 = dC2) # create a vector for the parameters for experiment #2
rm2 <- ode(i.state2, 1:Time, RM_2C_2R, p.rm2) # run the experiment
# replicate Fig. 3a
matplot(rm2[,1], rm2[,c(2,3,4,5)],
type = "l", ylab="Density", xlab="Time", ylim=c(0, C*15), main = "2 Consumers, 2 Resources", lwd = 3)
legend("top", c("R1","R2", "C1", "C2"), lty=1:4, col=1:4, bty="n", lwd = 3)
# new state variables for model
C2 <- C1
i.state2 <- c(R1 = R1, R2 = R2, C1 = C1, C2 = C2)
# new parameters for model
e2 <- e1
dC2 <- dC1
# run the experiment. This experiment essentially solves the model at the initial C and R densities, and takes the new C and R densities and reruns the model, and so on until the end of time.
p.rm2 <- c(r1 = r1, r2 = r2,
K1 = K1, K2 = K2,
e1 = e1, e2 = e2,
a1 = a1*5, a2 = a2,
h1 = h1/3, h2 = h2,
dC1 = dC1, dC1 = dC2) # create a vector for the parameters for experiment #2
rm2 <- ode(i.state2, 1:Time, RM_2C_2R, p.rm2) # run the experiment
# replicate Fig. 3a
matplot(rm2[,1], rm2[,c(2,3,4,5)],
type = "l", ylab="Density", xlab="Time", ylim=c(0, C*15), main = "2 Consumers, 2 Resources", lwd = 3)
legend("top", c("R1","R2", "C1", "C2"), lty=1:4, col=1:4, bty="n", lwd = 3)
# state variable values (initial values at beginning of "experiments")
R1 <- R2 <- 1
C1 <- 0.2
i.state <- c(R1 = R1, R2 = R2, C1 = C1)
# parameter values
r1 <- r2 <- 1 # per capita rate of increase in resource
K1 <- K2 <- 2 # carrying capacity
e1 <- 0.3 # predator conversion efficiency
h1 <- h2 <- 0.03 # handling time
dC1 <- 0.5 # mortality rate of predator
a1 <- a2 <- 1 # attack rate of Consumer
# run the experiment. This experiment essentially solves the model at the initial C and R densities, and takes the new C and R densities and reruns the model, and so on until the end of time.
p.rm1 <- c(r1 = r1, r2 = r2,
K1 = K1, K2 = K2,
e1 = e1,
a1 = a1*5, a2 = a2,
h1 = h1, h2 = h2,
dC1 = dC1) # create a vector for the parameters for experiment #1
Time <- 400 # set time scale
rm1 <- ode(i.state, 1:Time, RM_apparent, p.rm1) # run the experiment
# replicate Fig. 3a
matplot(rm1[,1], rm1[,c(2,3,4)],
type = "l", ylab="Density", xlab="Time", ylim=c(0, C*15), main = "Apparent Competition", lwd = 3)
legend("top", c("R1","R2", "C"), lty=1:3, col=1:3, bty="n", lwd = 3)
# new state variables for model
C2 <- C1
i.state2 <- c(R1 = R1, R2 = R2, C1 = C1, C2 = C2)
# new parameters for model
e2 <- e1
dC2 <- dC1
# run the experiment. This experiment essentially solves the model at the initial C and R densities, and takes the new C and R densities and reruns the model, and so on until the end of time.
p.rm2 <- c(r1 = r1, r2 = r2,
K1 = K1, K2 = K2,
e1 = e1, e2 = e2,
a1 = a1*5, a2 = a2*5,
h1 = h1, h2 = h2,
dC1 = dC1, dC1 = dC2) # create a vector for the parameters for experiment #2
rm2 <- ode(i.state2, 1:Time, RM_2C_2R, p.rm2) # run the experiment
# replicate Fig. 3a
matplot(rm2[,1], rm2[,c(2,3,4,5)],
type = "l", ylab="Density", xlab="Time", ylim=c(0, C*15), main = "2 Consumers, 2 Resources", lwd = 3)
legend("top", c("R1","R2", "C1", "C2"), lty=1:4, col=1:4, bty="n", lwd = 3)
# state variable values (initial values at beginning of "experiments")
R1 <- R2 <- 1
C1 <- 0.2
i.state <- c(R1 = R1, R2 = R2, C1 = C1)
# parameter values
r1 <- r2 <- 1 # per capita rate of increase in resource
K1 <- K2 <- 2 # carrying capacity
e1 <- 0.3 # predator conversion efficiency
h1 <- h2 <- 0.03 # handling time
dC1 <- 0.5 # mortality rate of predator
a1 <- a2 <- 1 # attack rate of Consumer
# run the experiment. This experiment essentially solves the model at the initial C and R densities, and takes the new C and R densities and reruns the model, and so on until the end of time.
p.rm1 <- c(r1 = r1, r2 = r2,
K1 = K1, K2 = K2,
e1 = e1,
a1 = a1*5, a2 = a2*5,
h1 = h1, h2 = h2,
dC1 = dC1) # create a vector for the parameters for experiment #1
Time <- 400 # set time scale
rm1 <- ode(i.state, 1:Time, RM_apparent, p.rm1) # run the experiment
# replicate Fig. 3a
matplot(rm1[,1], rm1[,c(2,3,4)],
type = "l", ylab="Density", xlab="Time", ylim=c(0, C*15), main = "Apparent Competition", lwd = 3)
legend("top", c("R1","R2", "C"), lty=1:3, col=1:3, bty="n", lwd = 3)
# new state variables for model
C2 <- C1
i.state2 <- c(R1 = R1, R2 = R2, C1 = C1, C2 = C2)
# new parameters for model
e2 <- e1
dC2 <- dC1
# run the experiment. This experiment essentially solves the model at the initial C and R densities, and takes the new C and R densities and reruns the model, and so on until the end of time.
p.rm2 <- c(r1 = r1, r2 = r2,
K1 = K1, K2 = K2,
e1 = e1, e2 = e2,
a1 = a1, a2 = a2,
h1 = h1/3, h2 = h2*3,
dC1 = dC1, dC1 = dC2) # create a vector for the parameters for experiment #2
rm2 <- ode(i.state2, 1:Time, RM_2C_2R, p.rm2) # run the experiment
# replicate Fig. 3a
matplot(rm2[,1], rm2[,c(2,3,4,5)],
type = "l", ylab="Density", xlab="Time", ylim=c(0, C*15), main = "2 Consumers, 2 Resources", lwd = 3)
legend("top", c("R1","R2", "C1", "C2"), lty=1:4, col=1:4, bty="n", lwd = 3)
# new state variables for model
C2 <- C1
i.state2 <- c(R1 = R1, R2 = R2, C1 = C1, C2 = C2)
# new parameters for model
e2 <- e1
dC2 <- dC1
# run the experiment. This experiment essentially solves the model at the initial C and R densities, and takes the new C and R densities and reruns the model, and so on until the end of time.
p.rm2 <- c(r1 = r1, r2 = r2,
K1 = K1, K2 = K2,
e1 = e1, e2 = e2,
a1 = a1, a2 = a2,
h1 = h1*3, h2 = h2*3,
dC1 = dC1, dC1 = dC2) # create a vector for the parameters for experiment #2
rm2 <- ode(i.state2, 1:Time, RM_2C_2R, p.rm2) # run the experiment
# replicate Fig. 3a
matplot(rm2[,1], rm2[,c(2,3,4,5)],
type = "l", ylab="Density", xlab="Time", ylim=c(0, C*15), main = "2 Consumers, 2 Resources", lwd = 3)
legend("top", c("R1","R2", "C1", "C2"), lty=1:4, col=1:4, bty="n", lwd = 3)
# new state variables for model
C2 <- C1
i.state2 <- c(R1 = R1, R2 = R2, C1 = C1, C2 = C2)
# new parameters for model
e2 <- e1
dC2 <- dC1
# run the experiment. This experiment essentially solves the model at the initial C and R densities, and takes the new C and R densities and reruns the model, and so on until the end of time.
p.rm2 <- c(r1 = r1, r2 = r2,
K1 = K1, K2 = K2,
e1 = e1, e2 = e2,
a1 = a1, a2 = a2,
h1 = h1*10, h2 = h2*10,
dC1 = dC1, dC1 = dC2) # create a vector for the parameters for experiment #2
rm2 <- ode(i.state2, 1:Time, RM_2C_2R, p.rm2) # run the experiment
# replicate Fig. 3a
matplot(rm2[,1], rm2[,c(2,3,4,5)],
type = "l", ylab="Density", xlab="Time", ylim=c(0, C*15), main = "2 Consumers, 2 Resources", lwd = 3)
legend("top", c("R1","R2", "C1", "C2"), lty=1:4, col=1:4, bty="n", lwd = 3)
# new state variables for model
C2 <- C1
i.state2 <- c(R1 = R1, R2 = R2, C1 = C1, C2 = C2)
# new parameters for model
e2 <- e1
dC2 <- dC1
# run the experiment. This experiment essentially solves the model at the initial C and R densities, and takes the new C and R densities and reruns the model, and so on until the end of time.
p.rm2 <- c(r1 = r1, r2 = r2,
K1 = K1, K2 = K2,
e1 = e1, e2 = e2,
a1 = a1, a2 = a2*10,
h1 = h1, h2 = h2,
dC1 = dC1, dC1 = dC2) # create a vector for the parameters for experiment #2
rm2 <- ode(i.state2, 1:Time, RM_2C_2R, p.rm2) # run the experiment
# replicate Fig. 3a
matplot(rm2[,1], rm2[,c(2,3,4,5)],
type = "l", ylab="Density", xlab="Time", ylim=c(0, C*15), main = "2 Consumers, 2 Resources", lwd = 3)
legend("top", c("R1","R2", "C1", "C2"), lty=1:4, col=1:4, bty="n", lwd = 3)
# new state variables for model
C2 <- C1
i.state2 <- c(R1 = R1, R2 = R2, C1 = C1, C2 = C2)
# new parameters for model
e2 <- e1
dC2 <- dC1
# run the experiment. This experiment essentially solves the model at the initial C and R densities, and takes the new C and R densities and reruns the model, and so on until the end of time.
p.rm2 <- c(r1 = r1, r2 = r2,
K1 = K1, K2 = K2,
e1 = e1, e2 = e2,
a1 = a1, a2 = a2,
h1 = h1, h2 = h2,
dC1 = dC1, dC1 = dC2) # create a vector for the parameters for experiment #2
rm2 <- ode(i.state2, 1:Time, RM_2C_2R, p.rm2) # run the experiment
# replicate Fig. 3a
matplot(rm2[,1], rm2[,c(2,3,4,5)],
type = "l", ylab="Density", xlab="Time", ylim=c(0, C*15), main = "2 Consumers, 2 Resources", lwd = 3)
legend("top", c("R1","R2", "C1", "C2"), lty=1:4, col=1:4, bty="n", lwd = 3)
# state variable values (initial values at beginning of "experiments")
R1 <- R2 <- 1
C1 <- 0.2
i.state <- c(R1 = R1, R2 = R2, C1 = C1)
# parameter values
r1 <- r2 <- 1 # per capita rate of increase in resource
K1 <- K2 <- 2 # carrying capacity
e1 <- 0.3 # predator conversion efficiency
h1 <- h2 <- 0.03 # handling time
dC1 <- 0.5 # mortality rate of predator
a1 <- a2 <- 1 # attack rate of Consumer
# run the experiment. This experiment essentially solves the model at the initial C and R densities, and takes the new C and R densities and reruns the model, and so on until the end of time.
p.rm1 <- c(r1 = r1, r2 = r2,
K1 = K1, K2 = K2,
e1 = e1,
a1 = a1, a2 = a2,
h1 = h1, h2 = h2,
dC1 = dC1) # create a vector for the parameters for experiment #1
Time <- 400 # set time scale
rm1 <- ode(i.state, 1:Time, RM_apparent, p.rm1) # run the experiment
# replicate Fig. 3a
matplot(rm1[,1], rm1[,c(2,3,4)],
type = "l", ylab="Density", xlab="Time", ylim=c(0, C*15), main = "Apparent Competition", lwd = 3)
legend("top", c("R1","R2", "C"), lty=1:3, col=1:3, bty="n", lwd = 3)
# state variable values (initial values at beginning of "experiments")
R1 <- R2 <- 1
C1 <- 0.2
i.state <- c(R1 = R1, R2 = R2, C1 = C1)
# parameter values
r1 <- r2 <- 1 # per capita rate of increase in resource
K1 <- K2 <- 2 # carrying capacity
e1 <- 0.3 # predator conversion efficiency
h1 <- h2 <- 0.03 # handling time
dC1 <- 0.5 # mortality rate of predator
a1 <- a2 <- 1 # attack rate of Consumer
# run the experiment. This experiment essentially solves the model at the initial C and R densities, and takes the new C and R densities and reruns the model, and so on until the end of time.
p.rm1 <- c(r1 = r1, r2 = r2,
K1 = K1, K2 = K2,
e1 = e1,
a1 = a1*3, a2 = a2*3,
h1 = h1, h2 = h2,
dC1 = dC1) # create a vector for the parameters for experiment #1
Time <- 400 # set time scale
rm1 <- ode(i.state, 1:Time, RM_apparent, p.rm1) # run the experiment
# replicate Fig. 3a
matplot(rm1[,1], rm1[,c(2,3,4)],
type = "l", ylab="Density", xlab="Time", ylim=c(0, C*15), main = "Apparent Competition", lwd = 3)
legend("top", c("R1","R2", "C"), lty=1:3, col=1:3, bty="n", lwd = 3)
# new state variables for model
C2 <- C1
i.state2 <- c(R1 = R1, R2 = R2, C1 = C1, C2 = C2)
# new parameters for model
e2 <- e1
dC2 <- dC1
# run the experiment. This experiment essentially solves the model at the initial C and R densities, and takes the new C and R densities and reruns the model, and so on until the end of time.
p.rm2 <- c(r1 = r1, r2 = r2,
K1 = K1, K2 = K2,
e1 = e1, e2 = e2,
a1 = a1*3, a2 = a2*3,
h1 = h1, h2 = h2,
dC1 = dC1, dC1 = dC2) # create a vector for the parameters for experiment #2
rm2 <- ode(i.state2, 1:Time, RM_2C_2R, p.rm2) # run the experiment
# replicate Fig. 3a
matplot(rm2[,1], rm2[,c(2,3,4,5)],
type = "l", ylab="Density", xlab="Time", ylim=c(0, C*15), main = "2 Consumers, 2 Resources", lwd = 3)
legend("top", c("R1","R2", "C1", "C2"), lty=1:4, col=1:4, bty="n", lwd = 3)
# new state variables for model
C2 <- C1
i.state2 <- c(R1 = R1, R2 = R2, C1 = C1, C2 = C2)
# new parameters for model
e2 <- e1
dC2 <- dC1
# run the experiment. This experiment essentially solves the model at the initial C and R densities, and takes the new C and R densities and reruns the model, and so on until the end of time.
p.rm2 <- c(r1 = r1, r2 = r2,
K1 = K1, K2 = K2,
e1 = e1, e2 = e2,
a1 = a1*3, a2 = a2,
h1 = h1, h2 = h2,
dC1 = dC1, dC1 = dC2) # create a vector for the parameters for experiment #2
rm2 <- ode(i.state2, 1:Time, RM_2C_2R, p.rm2) # run the experiment
# replicate Fig. 3a
matplot(rm2[,1], rm2[,c(2,3,4,5)],
type = "l", ylab="Density", xlab="Time", ylim=c(0, C*15), main = "2 Consumers, 2 Resources", lwd = 3)
legend("top", c("R1","R2", "C1", "C2"), lty=1:4, col=1:4, bty="n", lwd = 3)
# state variable values (initial values at beginning of "experiments")
R1 <- R2 <- 1
C1 <- 0.2
i.state <- c(R1 = R1, R2 = R2, C1 = C1)
# parameter values
r1 <- r2 <- 1 # per capita rate of increase in resource
K1 <- K2 <- 2 # carrying capacity
e1 <- 0.3 # predator conversion efficiency
h1 <- h2 <- 0.03 # handling time
dC1 <- 0.5 # mortality rate of predator
a1 <- a2 <- 1 # attack rate of Consumer
# run the experiment. This experiment essentially solves the model at the initial C and R densities, and takes the new C and R densities and reruns the model, and so on until the end of time.
p.rm1 <- c(r1 = r1, r2 = r2,
K1 = K1, K2 = K2,
e1 = e1,
a1 = a1*3, a2 = a2,
h1 = h1, h2 = h2,
dC1 = dC1) # create a vector for the parameters for experiment #1
Time <- 400 # set time scale
rm1 <- ode(i.state, 1:Time, RM_apparent, p.rm1) # run the experiment
# replicate Fig. 3a
matplot(rm1[,1], rm1[,c(2,3,4)],
type = "l", ylab="Density", xlab="Time", ylim=c(0, C*15), main = "Apparent Competition", lwd = 3)
legend("top", c("R1","R2", "C"), lty=1:3, col=1:3, bty="n", lwd = 3)
# state variable values (initial values at beginning of "experiments")
R1 <- R2 <- 1
C1 <- 0.2
i.state <- c(R1 = R1, R2 = R2, C1 = C1)
# parameter values
r1 <- r2 <- 1 # per capita rate of increase in resource
K1 <- K2 <- 2 # carrying capacity
e1 <- 0.3 # predator conversion efficiency
h1 <- h2 <- 0.03 # handling time
dC1 <- 0.5 # mortality rate of predator
a1 <- a2 <- 1 # attack rate of Consumer
# run the experiment. This experiment essentially solves the model at the initial C and R densities, and takes the new C and R densities and reruns the model, and so on until the end of time.
p.rm1 <- c(r1 = r1, r2 = r2,
K1 = K1, K2 = K2,
e1 = e1,
a1 = a1, a2 = a2,
h1 = h1*10, h2 = h2*10,
dC1 = dC1) # create a vector for the parameters for experiment #1
Time <- 400 # set time scale
rm1 <- ode(i.state, 1:Time, RM_apparent, p.rm1) # run the experiment
# replicate Fig. 3a
matplot(rm1[,1], rm1[,c(2,3,4)],
type = "l", ylab="Density", xlab="Time", ylim=c(0, C*15), main = "Apparent Competition", lwd = 3)
legend("top", c("R1","R2", "C"), lty=1:3, col=1:3, bty="n", lwd = 3)
# state variable values (initial values at beginning of "experiments")
R1 <- R2 <- 1
C1 <- 0.2
i.state <- c(R1 = R1, R2 = R2, C1 = C1)
# parameter values
r1 <- r2 <- 1 # per capita rate of increase in resource
K1 <- K2 <- 2 # carrying capacity
e1 <- 0.3 # predator conversion efficiency
h1 <- h2 <- 0.03 # handling time
dC1 <- 0.5 # mortality rate of predator
a1 <- a2 <- 1 # attack rate of Consumer
# run the experiment. This experiment essentially solves the model at the initial C and R densities, and takes the new C and R densities and reruns the model, and so on until the end of time.
p.rm1 <- c(r1 = r1, r2 = r2,
K1 = K1, K2 = K2,
e1 = e1,
a1 = a1, a2 = a2,
h1 = h1*20, h2 = h2*20,
dC1 = dC1) # create a vector for the parameters for experiment #1
Time <- 400 # set time scale
rm1 <- ode(i.state, 1:Time, RM_apparent, p.rm1) # run the experiment
# replicate Fig. 3a
matplot(rm1[,1], rm1[,c(2,3,4)],
type = "l", ylab="Density", xlab="Time", ylim=c(0, C*15), main = "Apparent Competition", lwd = 3)
legend("top", c("R1","R2", "C"), lty=1:3, col=1:3, bty="n", lwd = 3)
# state variable values (initial values at beginning of "experiments")
R1 <- R2 <- 1
C1 <- 0.2
i.state <- c(R1 = R1, R2 = R2, C1 = C1)
# parameter values
r1 <- r2 <- 1 # per capita rate of increase in resource
K1 <- K2 <- 2 # carrying capacity
e1 <- 0.3 # predator conversion efficiency
h1 <- h2 <- 0.03 # handling time
dC1 <- 0.5 # mortality rate of predator
a1 <- a2 <- 1 # attack rate of Consumer
# run the experiment. This experiment essentially solves the model at the initial C and R densities, and takes the new C and R densities and reruns the model, and so on until the end of time.
p.rm1 <- c(r1 = r1, r2 = r2,
K1 = K1, K2 = K2,
e1 = e1,
a1 = a1*10, a2 = a2*10,
h1 = h1*10, h2 = h2*10,
dC1 = dC1) # create a vector for the parameters for experiment #1
Time <- 400 # set time scale
rm1 <- ode(i.state, 1:Time, RM_apparent, p.rm1) # run the experiment
# replicate Fig. 3a
matplot(rm1[,1], rm1[,c(2,3,4)],
type = "l", ylab="Density", xlab="Time", ylim=c(0, C*15), main = "Apparent Competition", lwd = 3)
legend("top", c("R1","R2", "C"), lty=1:3, col=1:3, bty="n", lwd = 3)
# state variable values (initial values at beginning of "experiments")
R1 <- R2 <- 1
C1 <- 0.2
i.state <- c(R1 = R1, R2 = R2, C1 = C1)
# parameter values
r1 <- r2 <- 1 # per capita rate of increase in resource
K1 <- K2 <- 2 # carrying capacity
e1 <- 0.3 # predator conversion efficiency
h1 <- h2 <- 0.03 # handling time
dC1 <- 0.5 # mortality rate of predator
a1 <- a2 <- 1 # attack rate of Consumer
# run the experiment. This experiment essentially solves the model at the initial C and R densities, and takes the new C and R densities and reruns the model, and so on until the end of time.
p.rm1 <- c(r1 = r1, r2 = r2,
K1 = K1, K2 = K2,
e1 = e1,
a1 = a1*2, a2 = a2*2,
h1 = h1*10, h2 = h2*10,
dC1 = dC1) # create a vector for the parameters for experiment #1
Time <- 400 # set time scale
rm1 <- ode(i.state, 1:Time, RM_apparent, p.rm1) # run the experiment
# replicate Fig. 3a
matplot(rm1[,1], rm1[,c(2,3,4)],
type = "l", ylab="Density", xlab="Time", ylim=c(0, C*15), main = "Apparent Competition", lwd = 3)
legend("top", c("R1","R2", "C"), lty=1:3, col=1:3, bty="n", lwd = 3)
# state variable values (initial values at beginning of "experiments")
R1 <- R2 <- 1
C1 <- 0.2
i.state <- c(R1 = R1, R2 = R2, C1 = C1)
# parameter values
r1 <- r2 <- 1 # per capita rate of increase in resource
K1 <- K2 <- 2 # carrying capacity
e1 <- 0.3 # predator conversion efficiency
h1 <- h2 <- 0.03 # handling time
dC1 <- 0.5 # mortality rate of predator
a1 <- a2 <- 1 # attack rate of Consumer
# run the experiment. This experiment essentially solves the model at the initial C and R densities, and takes the new C and R densities and reruns the model, and so on until the end of time.
p.rm1 <- c(r1 = r1, r2 = r2,
K1 = K1, K2 = K2,
e1 = e1,
a1 = a1*3, a2 = a2*3,
h1 = h1*10, h2 = h2*10,
dC1 = dC1) # create a vector for the parameters for experiment #1
Time <- 400 # set time scale
rm1 <- ode(i.state, 1:Time, RM_apparent, p.rm1) # run the experiment
# replicate Fig. 3a
matplot(rm1[,1], rm1[,c(2,3,4)],
type = "l", ylab="Density", xlab="Time", ylim=c(0, C*15), main = "Apparent Competition", lwd = 3)
legend("top", c("R1","R2", "C"), lty=1:3, col=1:3, bty="n", lwd = 3)
## source in required datasets and functions.
source('~/Documents/Genotype_Networks/Rscripts/network_management_tree_level.R')
source('~/Documents/miscellaneous_R/model_diagnostic_functions.R')
source('~/Documents/miscellaneous_R/jensen_magnitude_function.R')
## load required libraries
#library(vegan) # for adonis analysis
#library(knitr) # for making tables
library(ggplot2) # for plotting
theme_set(theme_classic()) # customize ggplot for prettier default graphs
library(gridExtra) # for grid.arrange
library(mvabund) # multivariate analysis
library(HH) # for variance inflation factor analysis (vif) in multiple regression
## create datasets for analysis
full.df <- tree_level_interaxn_all_plants_traits_size
interaxns_noPont # all gall-parasitoid interactions used for analysis
# selects galls and traits for analysis
galls.traits.df <- full.df %>%
select(aSG_abund:SG_abund,
vLG.height.mean, vLG.gall.count,
Trichome.No., Total_Area, Height, Density,
C_N_imputed, water_content, specific_leaf_area, sal_tannin.PC1:flavanonOLES.PC1)
# create some new variables to reduce multicollinearity among non-principal component traits
gall.density.df <- galls.traits.df %>%
mutate(log_size = log(Total_Area),
log_trichomes = log(Trichome.No.+1)) %>%
select(aSG_abund:SG_abund, Height:log_trichomes) %>%
na.omit()
gall.density.df$Height_resid = resid(lm(Height ~ log_size, gall.density.df))
gall.density.df$Density_resid = resid(lm(Density ~ log_size, gall.density.df))
gall.density.df$SLA_resid = resid(lm(specific_leaf_area ~ water_content, gall.density.df))
# subset the final datasets
galls_galls.traits <- mvabund(select(gall.density.df, aSG_abund:SG_abund))
traits_galls.traits <- select(gall.density.df, C_N_imputed, water_content, sal_tannin.PC1:SLA_resid)
mvabund.galls.traits <- manyglm(galls_galls.traits ~ C_N_imputed + water_content + sal_tannin.PC1 + cinn.PC1 + cinn.PC2 + flavonOLES.PC1 + flavonOLES.PC2 + flavanonOLES.PC1 + log_size + log_trichomes + Height_resid + Density_resid + SLA_resid,
data = traits_galls.traits,
family = "negative.binomial")
plot(mvabund.galls.traits, which = 1:3)
library(glmulti)
glmulti(mvabund.galls.traits)
glmulti(y = mvabund.galls.traits)
glmulti(y = mvabund.galls.traits$AICsum)
drop1(mvabund.galls.traits)
mod2 <- update(mvabund.galls.traits, .~. - sal_tannin.PC1); drop1(mod2)
mod3 <- update(mod2, .~. - flavonOLES.PC1); drop1(mod3)
mod4 <- update(mod3, .~. -water_content); drop1(mod4)
mod5 <- update(mod4, .~. - cinn.PC2); drop1(mod5)
mod6 <- update(mod5, .~. - cinn.PC1); drop1(mod6)
mod7 <- update(mod6, .~. -SLA_resid); drop1(mod7)
mod8 <- update(mod7, .~. -Height_resid); drop1(mod8)
mod9 <- update(mod8, .~. -Density_resid); drop1(mod9)
mod10 <- update(mod9, .~. -flavonOLES.PC2); drop1(mod10)
mod11 <- update(mod10, .~. -log_trichomes); drop1(mod11)
mod12 <- update(mod11, .~. -C_N_imputed); drop1(mod12)
mod13 <- update(mod12, .~. -log_size); drop1(mod13)
mod14.null <- update(mod13, .~. -flavanonOLES.PC1)
## use AIC to compare models
AIC.models.galls.traits <- data.frame(Model = 1:14, # progressive order in which models were fit
Formula = c(paste(formula(mvabund.galls.traits)[3]),
paste(formula(mod2)[3]),
paste(formula(mod3)[3]),
paste(formula(mod4)[3]),
paste(formula(mod5)[3]),
paste(formula(mod6)[3]),
paste(formula(mod7)[3]),
paste(formula(mod8)[3]),
paste(formula(mod9)[3]),
paste(formula(mod10)[3]),
paste(formula(mod11)[3]),
paste(formula(mod12)[3]),
paste(formula(mod13)[3]),
paste(formula(mod14.null)[3])),
AIC = c(sum(AIC(mvabund.galls.traits)),
sum(AIC(mod2)),
sum(AIC(mod3)),
sum(AIC(mod4)),
sum(AIC(mod5)),
sum(AIC(mod6)),
sum(AIC(mod7)),
sum(AIC(mod8)),
sum(AIC(mod9)),
sum(AIC(mod10)),
sum(AIC(mod11)),
sum(AIC(mod12)),
sum(AIC(mod13)),
sum(AIC(mod14.null))))
arrange(AIC.models.galls.traits, AIC)
library(MuMIn)
model.avg(mod13,mod14)
model.avg(mod13,mod12)
drop1(mvabund.galls.traits)
