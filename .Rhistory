# replace names in adjancencyMatrix
#rownames(adjacencyMatrix) <- rownames(web)
#colnames(adjacencyMatrix) <- colnames(web)
# melt the web
adjacencyList <- melt(adjacencyMatrix)  # Convert to list of ties only
adjacencyList <- adjacencyList[adjacencyList$value > 0, ]
if(!is.null(edge.list.extra)){
adjacencyList <- mutate(adjacencyList,
X1.names = rownames(web)[adjacencyList$X1],
X2.names = rownames(web)[adjacencyList$X2]) # adds extra information to edges, such as if you want to color them.
adjacencyList <- left_join(adjacencyList, edge.list.extra)
}
#browser()
# Function to generate paths between each connected node. Adapted from the following     gist -> http://is-r.tumblr.com/post/38459242505/beautiful-network-diagrams-with-ggplot2
edgeMaker <- function(whichRow, len = 1000, curved = TRUE){ # len originally 100
fromC <- layoutCoordinates[adjacencyList[whichRow, 1], ]  # Origin
toC <- layoutCoordinates[adjacencyList[whichRow, 2], ]  # Terminus
#browser()
# Add curve:
graphCenter <- colMeans(layoutCoordinates)  # Center of the overall graph
bezierMid <- c(fromC[1], toC[2])  # A midpoint, for bended edges
distance1 <- sum((graphCenter - bezierMid)^2)
if(distance1 < sum((graphCenter - c(toC[1], fromC[2]))^2)){
bezierMid <- c(toC[1], fromC[2])
}  # To select the best Bezier midpoint
bezierMid <- (fromC + toC + bezierMid) / 3  # Moderate the Bezier midpoint
if(curved == FALSE){bezierMid <- (fromC + toC) / 2}  # Remove the curve
edge <- data.frame(Hmisc::bezier(c(fromC[1], bezierMid[1], toC[1]),  # Generate
c(fromC[2], bezierMid[2], toC[2]),  # X & y
evaluation = len))  # Bezier path coordinates
edge$Sequence <- 1:len  # For size and colour weighting in plot
edge$Group <- paste(adjacencyList[whichRow, 1:2], collapse = ">")
edge$Weight <- adjacencyList[whichRow, 3]
if(!is.null(edge.list.extra)){
edge$Extra <- adjacencyList[whichRow, 6]
}
return(edge)
}
# Generate a (curved) edge path for each pair of connected nodes
allEdges <- lapply(1:nrow(adjacencyList), edgeMaker, len = 500, curved = TRUE)
allEdges <- do.call(rbind, allEdges)  # a fine-grained path ^, with bend ^
out <- list(allEdges, layout_df)
}
t <- tripartite_plot_info(metaweb.graph)
t
seq(4, 6)
seq(1, 6, length.out = 1)
3
seq(3,6, 1)
seq(3,6, length.out = 1)
seq(1,6, length.out = 4)
seq(2,5, length.out = 4)
seq(1.5,5.5, length.out = 4)
seq(1,6)
seq(1,5)
seq(0,1, length.out = 1)
seq(0,1, length.out = 11)
seq(1,6, length.out = 8)
seq(1,6, length.out = 4)
seq(1,6, length.out = 6)
seq(1,6, length.out = 3)
tripartite_plot_info <- function(net, # must be an adjacency network object
vertex.order = NULL,
edge.list.extra = NULL){ # vertices must have the names "X1.names" and "X2.names" for edge.list.extra
require(sna)
require(reshape2)
require(Hmisc)
require(igraph)
require(NetIndices)
require(dplyr)
web <- get.adjacency(net, sparse = F, attr = "weight")
#browser()
web.troph <- data.frame(NetIndices::TrophInd(web), deg.weight = graph.strength(net))
web.troph <- mutate(web.troph,
vertices = rownames(web.troph),
TL = round(TL)) # rounded for easier plotting of k-partite graphs
if(!is.null(vertex.order)){
web.troph <- web.troph
} else(web.troph <- arrange(web.troph, TL))
#deg.weight <- graph.strength(net)
#browser()
# create layout for triipartite network. Evenly spaces out trophic level with the fewest number of nodes
species.per.TL <- c(dim(filter(web.troph, TL == "1"))[1],
dim(filter(web.troph, TL == "2"))[1],
dim(filter(web.troph, TL == "3"))[1])
node.spacing <- which.max(species.per.TL)
species.spacing <- species.per.TL + 2
browser()
layout.tripartite <- matrix(nrow = dim(web.troph)[1], ncol = 2)
layout.tripartite[ ,1] <- c(seq(1, dim(filter(web.troph, TL == node.spacing))[1], length.out = dim(filter(web.troph, TL == "1"))[1]),
seq(1, dim(filter(web.troph, TL == node.spacing))[1], length.out = dim(filter(web.troph, TL == "2"))[1]),
seq(1, dim(filter(web.troph, TL == node.spacing))[1], length.out = dim(filter(web.troph, TL == "3"))[1]))
layout.tripartite[ ,2] <- web.troph$TL
#browser()
# reorder web based on arranged data frame
web <- web[web.troph$vertices,
web.troph$vertices]
#browser()
# name a replicate of the web "adjacencyMatrix" with unique, numbered values for each node. Necessary for accurate plotting.
adjacencyMatrix <- web
rownames(adjacencyMatrix) <- 1:length(V(net))
colnames(adjacencyMatrix) <- 1:length(V(net))
# get layout coordinates for graph
layoutCoordinates <- gplot(adjacencyMatrix,
coord = layout.tripartite,
jitter = FALSE,
label = web.troph$vertices) # allows user to double check that network is plotting correctly.
#browser()
# create an extra dataframe that will be useful for plotting node attributes
layout_df <- data.frame(layoutCoordinates,
vertex.names = web.troph$vertices,
vertex.trophic.level = web.troph$TL,
vertex.weights = web.troph$deg.weight) # sum of edge weights
# replace names in adjancencyMatrix
#rownames(adjacencyMatrix) <- rownames(web)
#colnames(adjacencyMatrix) <- colnames(web)
# melt the web
adjacencyList <- melt(adjacencyMatrix)  # Convert to list of ties only
adjacencyList <- adjacencyList[adjacencyList$value > 0, ]
if(!is.null(edge.list.extra)){
adjacencyList <- mutate(adjacencyList,
X1.names = rownames(web)[adjacencyList$X1],
X2.names = rownames(web)[adjacencyList$X2]) # adds extra information to edges, such as if you want to color them.
adjacencyList <- left_join(adjacencyList, edge.list.extra)
}
#browser()
# Function to generate paths between each connected node. Adapted from the following     gist -> http://is-r.tumblr.com/post/38459242505/beautiful-network-diagrams-with-ggplot2
edgeMaker <- function(whichRow, len = 1000, curved = TRUE){ # len originally 100
fromC <- layoutCoordinates[adjacencyList[whichRow, 1], ]  # Origin
toC <- layoutCoordinates[adjacencyList[whichRow, 2], ]  # Terminus
#browser()
# Add curve:
graphCenter <- colMeans(layoutCoordinates)  # Center of the overall graph
bezierMid <- c(fromC[1], toC[2])  # A midpoint, for bended edges
distance1 <- sum((graphCenter - bezierMid)^2)
if(distance1 < sum((graphCenter - c(toC[1], fromC[2]))^2)){
bezierMid <- c(toC[1], fromC[2])
}  # To select the best Bezier midpoint
bezierMid <- (fromC + toC + bezierMid) / 3  # Moderate the Bezier midpoint
if(curved == FALSE){bezierMid <- (fromC + toC) / 2}  # Remove the curve
edge <- data.frame(Hmisc::bezier(c(fromC[1], bezierMid[1], toC[1]),  # Generate
c(fromC[2], bezierMid[2], toC[2]),  # X & y
evaluation = len))  # Bezier path coordinates
edge$Sequence <- 1:len  # For size and colour weighting in plot
edge$Group <- paste(adjacencyList[whichRow, 1:2], collapse = ">")
edge$Weight <- adjacencyList[whichRow, 3]
if(!is.null(edge.list.extra)){
edge$Extra <- adjacencyList[whichRow, 6]
}
return(edge)
}
# Generate a (curved) edge path for each pair of connected nodes
allEdges <- lapply(1:nrow(adjacencyList), edgeMaker, len = 500, curved = TRUE)
allEdges <- do.call(rbind, allEdges)  # a fine-grained path ^, with bend ^
out <- list(allEdges, layout_df)
}
t <- tripartite_plot_info(metaweb.graph)
species.spacing
tripartite_plot_info <- function(net, # must be an adjacency network object
vertex.order = NULL,
edge.list.extra = NULL){ # vertices must have the names "X1.names" and "X2.names" for edge.list.extra
require(sna)
require(reshape2)
require(Hmisc)
require(igraph)
require(NetIndices)
require(dplyr)
web <- get.adjacency(net, sparse = F, attr = "weight")
#browser()
web.troph <- data.frame(NetIndices::TrophInd(web), deg.weight = graph.strength(net))
web.troph <- mutate(web.troph,
vertices = rownames(web.troph),
TL = round(TL)) # rounded for easier plotting of k-partite graphs
if(!is.null(vertex.order)){
web.troph <- web.troph
} else(web.troph <- arrange(web.troph, TL))
#deg.weight <- graph.strength(net)
#browser()
# create layout for triipartite network. Evenly spaces out trophic level with the fewest number of nodes
species.per.TL <- c(dim(filter(web.troph, TL == "1"))[1],
dim(filter(web.troph, TL == "2"))[1],
dim(filter(web.troph, TL == "3"))[1])
node.spacing <- which.max(species.per.TL)
species.spacing <- species.per.TL + 2
#browser()
layout.tripartite <- matrix(nrow = dim(web.troph)[1], ncol = 2)
layout.tripartite[ ,1] <- c(seq(1, dim(filter(web.troph, TL == node.spacing))[1], length.out = species.spacing[1]), #dim(filter(web.troph, TL == "1"))[1]),
seq(1, dim(filter(web.troph, TL == node.spacing))[1], length.out = species.spacing[2]), #dim(filter(web.troph, TL == "2"))[1]),
seq(1, dim(filter(web.troph, TL == node.spacing))[1], length.out = species.spacing[3])) #dim(filter(web.troph, TL == "3"))[1]))
layout.tripartite[ ,2] <- web.troph$TL
#browser()
# reorder web based on arranged data frame
web <- web[web.troph$vertices,
web.troph$vertices]
#browser()
# name a replicate of the web "adjacencyMatrix" with unique, numbered values for each node. Necessary for accurate plotting.
adjacencyMatrix <- web
rownames(adjacencyMatrix) <- 1:length(V(net))
colnames(adjacencyMatrix) <- 1:length(V(net))
# get layout coordinates for graph
layoutCoordinates <- gplot(adjacencyMatrix,
coord = layout.tripartite,
jitter = FALSE,
label = web.troph$vertices) # allows user to double check that network is plotting correctly.
#browser()
# create an extra dataframe that will be useful for plotting node attributes
layout_df <- data.frame(layoutCoordinates,
vertex.names = web.troph$vertices,
vertex.trophic.level = web.troph$TL,
vertex.weights = web.troph$deg.weight) # sum of edge weights
# replace names in adjancencyMatrix
#rownames(adjacencyMatrix) <- rownames(web)
#colnames(adjacencyMatrix) <- colnames(web)
# melt the web
adjacencyList <- melt(adjacencyMatrix)  # Convert to list of ties only
adjacencyList <- adjacencyList[adjacencyList$value > 0, ]
if(!is.null(edge.list.extra)){
adjacencyList <- mutate(adjacencyList,
X1.names = rownames(web)[adjacencyList$X1],
X2.names = rownames(web)[adjacencyList$X2]) # adds extra information to edges, such as if you want to color them.
adjacencyList <- left_join(adjacencyList, edge.list.extra)
}
#browser()
# Function to generate paths between each connected node. Adapted from the following     gist -> http://is-r.tumblr.com/post/38459242505/beautiful-network-diagrams-with-ggplot2
edgeMaker <- function(whichRow, len = 1000, curved = TRUE){ # len originally 100
fromC <- layoutCoordinates[adjacencyList[whichRow, 1], ]  # Origin
toC <- layoutCoordinates[adjacencyList[whichRow, 2], ]  # Terminus
#browser()
# Add curve:
graphCenter <- colMeans(layoutCoordinates)  # Center of the overall graph
bezierMid <- c(fromC[1], toC[2])  # A midpoint, for bended edges
distance1 <- sum((graphCenter - bezierMid)^2)
if(distance1 < sum((graphCenter - c(toC[1], fromC[2]))^2)){
bezierMid <- c(toC[1], fromC[2])
}  # To select the best Bezier midpoint
bezierMid <- (fromC + toC + bezierMid) / 3  # Moderate the Bezier midpoint
if(curved == FALSE){bezierMid <- (fromC + toC) / 2}  # Remove the curve
edge <- data.frame(Hmisc::bezier(c(fromC[1], bezierMid[1], toC[1]),  # Generate
c(fromC[2], bezierMid[2], toC[2]),  # X & y
evaluation = len))  # Bezier path coordinates
edge$Sequence <- 1:len  # For size and colour weighting in plot
edge$Group <- paste(adjacencyList[whichRow, 1:2], collapse = ">")
edge$Weight <- adjacencyList[whichRow, 3]
if(!is.null(edge.list.extra)){
edge$Extra <- adjacencyList[whichRow, 6]
}
return(edge)
}
# Generate a (curved) edge path for each pair of connected nodes
allEdges <- lapply(1:nrow(adjacencyList), edgeMaker, len = 500, curved = TRUE)
allEdges <- do.call(rbind, allEdges)  # a fine-grained path ^, with bend ^
out <- list(allEdges, layout_df)
}
t <- tripartite_plot_info(metaweb.graph)
tripartite_plot_info <- function(net, # must be an adjacency network object
vertex.order = NULL,
edge.list.extra = NULL){ # vertices must have the names "X1.names" and "X2.names" for edge.list.extra
require(sna)
require(reshape2)
require(Hmisc)
require(igraph)
require(NetIndices)
require(dplyr)
web <- get.adjacency(net, sparse = F, attr = "weight")
#browser()
web.troph <- data.frame(NetIndices::TrophInd(web), deg.weight = graph.strength(net))
web.troph <- mutate(web.troph,
vertices = rownames(web.troph),
TL = round(TL)) # rounded for easier plotting of k-partite graphs
if(!is.null(vertex.order)){
web.troph <- web.troph
} else(web.troph <- arrange(web.troph, TL))
#deg.weight <- graph.strength(net)
#browser()
# create layout for triipartite network. Evenly spaces out trophic level with the fewest number of nodes
species.per.TL <- c(dim(filter(web.troph, TL == "1"))[1],
dim(filter(web.troph, TL == "2"))[1],
dim(filter(web.troph, TL == "3"))[1])
node.spacing <- which.max(species.per.TL)
species.spacing <- species.per.TL + 2
#browser()
layout.tripartite <- matrix(nrow = dim(web.troph)[1], ncol = 2)
layout.tripartite[ ,1] <- c(seq(1, dim(filter(web.troph, TL == node.spacing))[1], length.out = species.spacing[1])[-c(1, species.spacing[1])], #dim(filter(web.troph, TL == "1"))[1]),
seq(1, dim(filter(web.troph, TL == node.spacing))[1], length.out = species.spacing[2])[-c(1, species.spacing[2])], #dim(filter(web.troph, TL == "2"))[1]),
seq(1, dim(filter(web.troph, TL == node.spacing))[1], length.out = species.spacing[3])[-c(1, species.spacing[3])]) #dim(filter(web.troph, TL == "3"))[1]))
layout.tripartite[ ,2] <- web.troph$TL
#browser()
# reorder web based on arranged data frame
web <- web[web.troph$vertices,
web.troph$vertices]
#browser()
# name a replicate of the web "adjacencyMatrix" with unique, numbered values for each node. Necessary for accurate plotting.
adjacencyMatrix <- web
rownames(adjacencyMatrix) <- 1:length(V(net))
colnames(adjacencyMatrix) <- 1:length(V(net))
# get layout coordinates for graph
layoutCoordinates <- gplot(adjacencyMatrix,
coord = layout.tripartite,
jitter = FALSE,
label = web.troph$vertices) # allows user to double check that network is plotting correctly.
#browser()
# create an extra dataframe that will be useful for plotting node attributes
layout_df <- data.frame(layoutCoordinates,
vertex.names = web.troph$vertices,
vertex.trophic.level = web.troph$TL,
vertex.weights = web.troph$deg.weight) # sum of edge weights
# replace names in adjancencyMatrix
#rownames(adjacencyMatrix) <- rownames(web)
#colnames(adjacencyMatrix) <- colnames(web)
# melt the web
adjacencyList <- melt(adjacencyMatrix)  # Convert to list of ties only
adjacencyList <- adjacencyList[adjacencyList$value > 0, ]
if(!is.null(edge.list.extra)){
adjacencyList <- mutate(adjacencyList,
X1.names = rownames(web)[adjacencyList$X1],
X2.names = rownames(web)[adjacencyList$X2]) # adds extra information to edges, such as if you want to color them.
adjacencyList <- left_join(adjacencyList, edge.list.extra)
}
#browser()
# Function to generate paths between each connected node. Adapted from the following     gist -> http://is-r.tumblr.com/post/38459242505/beautiful-network-diagrams-with-ggplot2
edgeMaker <- function(whichRow, len = 1000, curved = TRUE){ # len originally 100
fromC <- layoutCoordinates[adjacencyList[whichRow, 1], ]  # Origin
toC <- layoutCoordinates[adjacencyList[whichRow, 2], ]  # Terminus
#browser()
# Add curve:
graphCenter <- colMeans(layoutCoordinates)  # Center of the overall graph
bezierMid <- c(fromC[1], toC[2])  # A midpoint, for bended edges
distance1 <- sum((graphCenter - bezierMid)^2)
if(distance1 < sum((graphCenter - c(toC[1], fromC[2]))^2)){
bezierMid <- c(toC[1], fromC[2])
}  # To select the best Bezier midpoint
bezierMid <- (fromC + toC + bezierMid) / 3  # Moderate the Bezier midpoint
if(curved == FALSE){bezierMid <- (fromC + toC) / 2}  # Remove the curve
edge <- data.frame(Hmisc::bezier(c(fromC[1], bezierMid[1], toC[1]),  # Generate
c(fromC[2], bezierMid[2], toC[2]),  # X & y
evaluation = len))  # Bezier path coordinates
edge$Sequence <- 1:len  # For size and colour weighting in plot
edge$Group <- paste(adjacencyList[whichRow, 1:2], collapse = ">")
edge$Weight <- adjacencyList[whichRow, 3]
if(!is.null(edge.list.extra)){
edge$Extra <- adjacencyList[whichRow, 6]
}
return(edge)
}
# Generate a (curved) edge path for each pair of connected nodes
allEdges <- lapply(1:nrow(adjacencyList), edgeMaker, len = 500, curved = TRUE)
allEdges <- do.call(rbind, allEdges)  # a fine-grained path ^, with bend ^
out <- list(allEdges, layout_df)
}
t <- tripartite_plot_info(metaweb.graph)
metaweb.info <- tripartite_plot_info(metaweb.graph)
interaction.df <- metaweb.info[[1]] %>%
mutate(x = as.numeric(x), y = as.numeric(y)) %>%
filter(Sequence == 500 | Sequence == 1) %>%
reshape(idvar = "Group", timevar = "Sequence", direction = "wide") %>%
mutate(weight.trans = Weight.1)
interaction.df
metaweb.info[[2]]
nodeinfo.df <- metaweb.info[[2]]# %>%
#mutate(guild = factor(c(rep("gall", 4),
#                        "Predator",
#                        rep("Larval\nparasitoid", 3),
#                        rep("Egg\nparasitoid", 2))),
#      names = c("Cecidomyiid",
#               "Rab. (bud)",
#              "Iteomyia",
#             "Rab. (stem)",
#            "Lestodiplosis", "Torymus", "Eulophid", "Mesopolobus", "Platygaster", "Mymarid"))
new_theme_empty <- theme_bw()
new_theme_empty$line <- element_blank()
new_theme_empty$rect <- element_blank()
new_theme_empty$strip.text <- element_blank()
new_theme_empty$axis.text <- element_blank()
new_theme_empty$plot.title <- element_blank()
new_theme_empty$axis.title <- element_blank()
new_theme_empty$plot.margin <- structure(c(2, 2, 2, 2), unit = "lines", # c(0,0,-1,-1) # 1,1,1,1
valid.unit = 3L, class = "unit")
metaweb.plot <- ggplot(interaction.df) +
geom_segment(data = interaction.df, aes(x = x.1, xend = x.500, y = y.1, yend = y.500),
color = "grey",
size = interaction.df$weight.trans/max(interaction.df$weight.trans)*25,
alpha = 0.75)  +
new_theme_empty +
geom_point(data = filter(nodeinfo.df, y > 1), aes(x = x, y = y, fill = vertex.names, shape = guild),
color = "black",
#shape = 25,
size = 30)  +
scale_shape_manual(values = c(25, 22, 23), name = "Natural enemy guild") +
#geom_text(data = filter(nodeinfo.df, y > 1), aes(x = x, y = y + 0.15, label = names), size = 6) +
geom_point(data = filter(nodeinfo.df, y == 1), aes(x = x, y = y, fill = vertex.names),
color = "black",
shape = 21,
size = 30) +
scale_fill_brewer(palette = "Spectral", guide = "none") +
geom_text(data = filter(nodeinfo.df, y == 1), aes(x = x, y = y - 0.15, label = names), size = 8) +
theme(legend.text = element_text(size = 14),
legend.title = element_text(size = 16))
#Code to override clipping
metaweb.plot
gt <- ggplot_gtable(ggplot_build(metaweb.plot))
gt$layout$clip[gt$layout$name == "panel"] <- "off"
grid.draw(gt)
interaction.df
metaweb.info[[1]]
metaweb.info[[2]]
ggplot(interaction.df) +
geom_segment(data = interaction.df, aes(x = x.1, xend = x.500, y = y.1, yend = y.500),
color = "grey",
size = interaction.df$weight.trans/max(interaction.df$weight.trans)*25,
alpha = 0.75)  +
new_theme_empty
ggplot(interaction.df) +
geom_segment(data = interaction.df, aes(x = x.1, xend = x.500, y = y.1, yend = y.500),
color = "grey",
size = interaction.df$weight.trans/max(interaction.df$weight.trans)*25,
alpha = 0.75)  +
new_theme_empty +
geom_point(data = filter(nodeinfo.df, y > 1), aes(x = x, y = y, fill = vertex.names, shape = guild),
color = "black",
#shape = 25,
size = 30)
ggplot(interaction.df) +
geom_segment(data = interaction.df, aes(x = x.1, xend = x.500, y = y.1, yend = y.500),
color = "grey",
size = interaction.df$weight.trans/max(interaction.df$weight.trans)*25,
alpha = 0.75)  +
new_theme_empty +
geom_point(data = filter(nodeinfo.df, y > 1), aes(x = x, y = y, fill = vertex.names),
color = "black",
#shape = 25,
size = 30)
nodeinfo.df
ggplot(interaction.df) +
geom_segment(data = interaction.df, aes(x = x.1, xend = x.500, y = y.1, yend = y.500),
color = "grey",
size = interaction.df$weight.trans/max(interaction.df$weight.trans)*25,
alpha = 0.75)  +
new_theme_empty +
geom_point(data = nodeinfo.df, aes(x = x, y = y, fill = vertex.names),
color = "black",
#shape = 25,
size = 1)
metaweb.plot <- ggplot(interaction.df) +
geom_segment(data = interaction.df, aes(x = x.1, xend = x.500, y = y.1, yend = y.500),
color = "grey",
size = interaction.df$weight.trans/max(interaction.df$weight.trans)*25,
alpha = 0.75)  +
new_theme_empty +
geom_point(data = nodeinfo.df, aes(x = x, y = y, fill = vertex.names),
color = "black",
#shape = 25,
size = 1) # +
#scale_shape_manual(values = c(25, 22, 23), name = "Natural enemy guild") +
#geom_text(data = filter(nodeinfo.df, y > 1), aes(x = x, y = y + 0.15, label = names), size = 6) +
#geom_point(data = filter(nodeinfo.df, y == 1), aes(x = x, y = y, fill = vertex.names),
#          color = "black",
#         shape = 21,
#        size = 30) +
#scale_fill_brewer(palette = "Spectral", guide = "none") +
#geom_text(data = filter(nodeinfo.df, y == 1), aes(x = x, y = y - 0.15, label = names), size = 8) +
#theme(legend.text = element_text(size = 14),
#     legend.title = element_text(size = 16))
#Code to override clipping
metaweb.plot
gt <- ggplot_gtable(ggplot_build(metaweb.plot))
gt$layout$clip[gt$layout$name == "panel"] <- "off"
grid.draw(gt)
ggplot(interaction.df) +
geom_segment(data = interaction.df, aes(x = x.1, xend = x.500, y = y.1, yend = y.500),
color = "grey",
size = interaction.df$weight.trans/max(interaction.df$weight.trans)*25,
alpha = 0.75)  +
new_theme_empty +
geom_point(data = nodeinfo.df, aes(x = x, y = y, fill = vertex.names),
color = "black",
#shape = 25,
size = 1, guide = "none")
ggplot(interaction.df) +
geom_segment(data = interaction.df, aes(x = x.1, xend = x.500, y = y.1, yend = y.500),
color = "grey",
size = interaction.df$weight.trans/max(interaction.df$weight.trans)*25,
alpha = 0.75)  +
new_theme_empty +
geom_point(data = nodeinfo.df, aes(x = x, y = y, fill = vertex.names),
color = "black",
#shape = 25,
size = 1, show_guide = FALSE)
metaweb.plot <- ggplot(interaction.df) +
geom_segment(data = interaction.df, aes(x = x.1, xend = x.500, y = y.1, yend = y.500),
color = "grey",
size = interaction.df$weight.trans/max(interaction.df$weight.trans)*25,
alpha = 0.75)  +
new_theme_empty +
geom_point(data = nodeinfo.df, aes(x = x, y = y, fill = vertex.names),
color = "black",
#shape = 25,
size = 1, show_guide = FALSE) # +
#scale_shape_manual(values = c(25, 22, 23), name = "Natural enemy guild") +
#geom_text(data = filter(nodeinfo.df, y > 1), aes(x = x, y = y + 0.15, label = names), size = 6) +
#geom_point(data = filter(nodeinfo.df, y == 1), aes(x = x, y = y, fill = vertex.names),
#          color = "black",
#         shape = 21,
#        size = 30) +
#scale_fill_brewer(palette = "Spectral", guide = "none") +
#geom_text(data = filter(nodeinfo.df, y == 1), aes(x = x, y = y - 0.15, label = names), size = 8) +
#theme(legend.text = element_text(size = 14),
#     legend.title = element_text(size = 16))
#Code to override clipping
metaweb.plot
gt <- ggplot_gtable(ggplot_build(metaweb.plot))
gt$layout$clip[gt$layout$name == "panel"] <- "off"
grid.draw(gt)
