---
title: "ms_willow_network_supplement"
author: "Matthew Barbour"
date: "January 31, 2015"
output: word_document
---

The code below replicates the analyses for the qualitative and quantitative network data.

```{r prepare, echo=FALSE}
## source in required datasets and functions. 
source('~/Documents/Genotype_Networks/Rscripts/network_management_tree_level.R')
source('~/Documents/miscellaneous_R/model_diagnostic_functions.R')
source('~/Documents/miscellaneous_R/jensen_magnitude_function.R')

## load required libraries
#library(vegan) # for adonis analysis
#library(knitr) # for making tables
library(ggplot2) # for plotting
theme_set(theme_classic()) # customize ggplot for prettier default graphs
library(gridExtra) # for grid.arrange
library(mvabund) # multivariate analysis
library(HH) # for variance inflation factor analysis (vif) in multiple regression

## create datasets for analysis
full.df <- tree_level_interaxn_all_plants_traits_size 
interaxns_noPont # all gall-parasitoid interactions used for analysis
```

```{r mv abund galls}
gall.mvabund <- mvabund(full.df[ ,c("vLG_abund","rG_abund","aSG_abund","SG_abund")])
meanvar.plot(gall.mvabund ~ full.df$Genotype)
poisson_curve(from = 0.1, to = 10)
quasipoisson_curve(from = 0.1, to = 10, quasi.scalar = 2)
neg.binomial_curve(from = 0.1, to = 10, theta.negbin = 0.7) # negative binomial provides the best fit to the data.
```

Assessed negative binomial assumptions
```{r gall abund negative binomial assumptions}
manyglm.gall <- manyglm(gall.mvabund ~ Genotype,
                        data = full.df,
                        family = "negative.binomial")
plot(manyglm.gall, which = 1:3) # residuals look really good. No heteroscadisticity or non-normality. Note that replotting the residuals gives qualitatively the same picture (it's important to replot them because the residuals involve random number generation, see ?plot.manyglm)
```

Tested whether genotype affected gall community composition
```{r gall abund test}
anova.gall <- anova.manyglm(manyglm.gall, p.uni = "adjusted")
anova.gall # vLG_abund, rG_abund and aSG_abund are driving the community response.
```

Boxplots of gall abundance among the different genotypes.
```{r gall abund across genotypes, echo = FALSE}
vLG.abund.plot <- ggplot(data = full.df, aes(x = Genotype, y = vLG_abund)) + 
  geom_boxplot() + ylab("Iteomyia salicisverruca density (#/branch)")
rG.abund.plot <- ggplot(data = full.df, aes(x = Genotype, y = rG_abund)) + 
  geom_boxplot() + ylab("Rabdophaga salicisbrassicoides density (#/branch)")
aSG.abund.plot <- ggplot(data = full.df, aes(x = Genotype, y = aSG_abund)) + 
  geom_boxplot() + ylab("Cecidomyid sp. A density (#/branch)")
SG.abund.plot <- ggplot(data = full.df, aes(x = Genotype, y = SG_abund)) + 
  geom_boxplot() + ylab("Rabdophaga salicisbattatus density (#/branch)")

grid.arrange(vLG.abund.plot, rG.abund.plot, aSG.abund.plot, SG.abund.plot)
```

```{r mvabund gall-trait associations}
# selects galls and traits for analysis
galls.traits.df <- full.df %>%
  select(aSG_abund:SG_abund,
         vLG.height.mean, vLG.gall.count,
         Trichome.No., Total_Area, Height, Density,
         C_N_imputed, water_content, specific_leaf_area, sal_tannin.PC1:flavanonOLES.PC1) 

# create some new variables to reduce multicollinearity among non-principal component traits
gall.density.df <- galls.traits.df %>%
  mutate(log_size = log(Total_Area),
         log_trichomes = log(Trichome.No.+1)) %>%
  select(aSG_abund:SG_abund, Height:log_trichomes) %>%
  na.omit()
gall.density.df$Height_resid = resid(lm(Height ~ log_size, gall.density.df))
gall.density.df$Density_resid = resid(lm(Density ~ log_size, gall.density.df))
gall.density.df$SLA_resid = resid(lm(specific_leaf_area ~ water_content, gall.density.df))

# subset the final datasets
galls_galls.traits <- mvabund(select(gall.density.df, aSG_abund:SG_abund))
traits_galls.traits <- select(gall.density.df, C_N_imputed, water_content, sal_tannin.PC1:SLA_resid)

mvabund.galls.traits <- manyglm(galls_galls.traits ~ C_N_imputed + water_content + sal_tannin.PC1 + cinn.PC1 + cinn.PC2 + flavonOLES.PC1 + flavonOLES.PC2 + flavanonOLES.PC1 + log_size + log_trichomes + Height_resid + Density_resid + SLA_resid, 
                                data = traits_galls.traits, 
                                family = "negative.binomial")
plot(mvabund.galls.traits, which = 1:3)
```

```{r stepAIC galls-traits}
## use stepAIC to identify traits that reduce AIC the most and remove them in a stepwise fashion from analysis.
drop1(mvabund.galls.traits)
mod2 <- update(mvabund.galls.traits, .~. - sal_tannin.PC1); drop1(mod2)
mod3 <- update(mod2, .~. - flavonOLES.PC1); drop1(mod3)
mod4 <- update(mod3, .~. -water_content); drop1(mod4)
mod5 <- update(mod4, .~. - cinn.PC2); drop1(mod5)
mod6 <- update(mod5, .~. - cinn.PC1); drop1(mod6)
mod7 <- update(mod6, .~. -SLA_resid); drop1(mod7)
mod8 <- update(mod7, .~. -Height_resid); drop1(mod8)
mod9 <- update(mod8, .~. -Density_resid); drop1(mod9)
mod10 <- update(mod9, .~. -flavonOLES.PC2); drop1(mod10)
mod11 <- update(mod10, .~. -log_trichomes); drop1(mod11)
mod12 <- update(mod11, .~. -C_N_imputed); drop1(mod12)
mod13 <- update(mod12, .~. -log_size); drop1(mod13)
mod14.null <- update(mod13, .~. -flavanonOLES.PC1)

## use AIC to compare models
AIC.models.galls.traits <- data.frame(Model = 1:14, # progressive order in which models were fit
           Formula = c(paste(formula(mvabund.galls.traits)[3]), 
                       paste(formula(mod2)[3]),
                       paste(formula(mod3)[3]), 
                       paste(formula(mod4)[3]),
                       paste(formula(mod5)[3]), 
                       paste(formula(mod6)[3]),
                       paste(formula(mod7)[3]),
                       paste(formula(mod8)[3]), 
                       paste(formula(mod9)[3]),
                       paste(formula(mod10)[3]), 
                       paste(formula(mod11)[3]),
                       paste(formula(mod12)[3]),
                       paste(formula(mod13)[3]),
                       paste(formula(mod14.null)[3])),
           AIC = c(sum(AIC(mvabund.galls.traits)), 
                   sum(AIC(mod2)), 
                   sum(AIC(mod3)), 
                   sum(AIC(mod4)),
                   sum(AIC(mod5)), 
                   sum(AIC(mod6)),
                   sum(AIC(mod7)), 
                   sum(AIC(mod8)), 
                   sum(AIC(mod9)),
                   sum(AIC(mod10)), 
                   sum(AIC(mod11)),
                   sum(AIC(mod12)), 
                   sum(AIC(mod13)), 
                   sum(AIC(mod14.null))))
arrange(AIC.models.galls.traits, AIC)

## Likelihood ratio tests suggest that all of the models with lower AIC than the null model provide a better fit to the data than the null.
anova.manyglm(mod14.null, mod13)
anova.manyglm(mod14.null, mod12)
anova.manyglm(mod14.null, mod11)
anova.manyglm(mod14.null, mod10)

# identify gall-trait associations. C_N_imputed has a marginally significant effect on Iteomyia and R. salicisbrassicoides abundance. FlavononOLES.PC1 has a signficiant effect on Cecidomyiid sp. A abundance, and plant size as a significant effect on R. salicisbrassicoides and a marginal effect on R. salicisbattatus abundance.
uni.galls.traits <-anova.manyglm(mod11, p.uni = "unadjusted")

coef.df <- data.frame(coef(mod11))

range.flavanonOLES.PC1 <- with(gall.density.df, max(flavanonOLES.PC1) - min(flavanonOLES.PC1))
exp(coef.df["flavanonOLES.PC1","aSG_abund"]*range.flavanonOLES.PC1) # over the range of flavanonOLES.PC1, Cecidomyiid sp. A abundance increased 15-fold

range.C_N_imputed <- with(gall.density.df, max(C_N_imputed) - min(C_N_imputed))
exp(coef.df["C_N_imputed", "vLG_abund"]*range.C_N_imputed) # over the range of C:N ratio, Iteomyia abundance increased 3-fold (2.9)

exp(coef.df["C_N_imputed", "rG_abund"]*range.C_N_imputed) # over the range of C:N ratio, R. salicisbrassicoides abundance increased 8-fold (7.6)

1 - 1.10^coef.df["log_size","rG_abund"] # for every 10% increase in plant size, R. salicisbrassicoides density decreased 9%

1 - 1.10^coef.df["log_size","SG_abund"] # for every 10% increase in plant size, R. salicisbattatus density decreasted by 37%
```

```{r visreg univariate gall-trait associations}
library(visreg)
# include model with all of the traits, but only examine one of the variables
vLG.trait <- MASS::glm.nb(vLG_abund ~ C_N_imputed + log_size + flavanonOLES.PC1, gall.density.df)
summary(vLG.trait) 
visreg(vLG.trait, xvar = "C_N_imputed", scale = "response")

aSG.trait <- MASS::glm.nb(aSG_abund ~ C_N_imputed + log_size + flavanonOLES.PC1, gall.density.df)
summary(aSG.trait)
visreg(aSG.trait, xvar = "flavanonOLES.PC1", scale = "response") # may or may not be too important

rG.trait <- MASS::glm.nb(rG_abund ~ C_N_imputed + log_size + flavanonOLES.PC1, gall.density.df)
summary(rG.trait)
visreg(rG.trait, xvar = "log_size", scale = "response")
visreg(rG.trait, xvar = "C_N_imputed", scale = "response")

SG.trait <- MASS::glm.nb(SG_abund ~ C_N_imputed + log_size + flavanonOLES.PC1, gall.density.df)
summary(SG.trait) # some warnings about lack of convergence
visreg(SG.trait, xvar = "log_size", scale = "response") # not a great fit. Outlier seems to be driving most of this relationship.
```

```{r}
## gall size
gall.size.df <- galls.traits.df %>%
  mutate(log_size = log(Total_Area),
         log_trichomes = log(Trichome.No.+1)) %>%
  select(vLG.height.mean, vLG.gall.count, Height:log_trichomes) %>%
  na.omit()
gall.size.df$Height_resid = resid(lm(Height ~ log_size, gall.size.df))
gall.size.df$Density_resid = resid(lm(Density ~ log_size, gall.size.df))
gall.size.df$SLA_resid = resid(lm(specific_leaf_area ~ water_content, gall.size.df))
gall.size.df <- select(gall.size.df, vLG.height.mean, vLG.gall.count, 
                       C_N_imputed, water_content,
                       sal_tannin.PC1:SLA_resid)

vLG.size.lm <- lm(vLG.height.mean ~ ., select(gall.size.df, -vLG.gall.count), weights = gall.size.df$vLG.gall.count)

drop1(vLG.size.lm)
size2 <- update(vLG.size.lm, .~. -C_N_imputed); drop1(size2)
size3 <- update(size2, .~. -Density_resid); drop1(size3)
size4 <- update(size3, .~. -flavonOLES.PC2); drop1(size4)
size5 <- update(size4, .~. -flavanonOLES.PC1); drop1(size5)
size6 <- update(size5, .~. -log_trichomes); drop1(size6)
size7 <- update(size6, .~. -SLA_resid); drop1(size7)
size8 <- update(size7, .~. -Height_resid); drop1(size8)
size9 <- update(size8, .~. -water_content); drop1(size9)
size10 <- update(size9, .~. -log_size); drop1(size10)
size11 <- update(size10, .~. -cinn.PC1); drop1(size11)
size12 <- update(size11, .~. -cinn.PC2); drop1(size12)
size13 <- update(size12, .~. -flavonOLES.PC1); drop1(size13)
size14.null <- update(size13, .~. -sal_tannin.PC1)

## use AIC to compare models
AIC.vLG.size.traits <- data.frame(Models = 1:14, # progressive order in which sizeels were fit
           Formula = c(paste(formula(vLG.size.lm)[3]), 
                       paste(formula(size2)[3]),
                       paste(formula(size3)[3]), 
                       paste(formula(size4)[3]),
                       paste(formula(size5)[3]), 
                       paste(formula(size6)[3]),
                       paste(formula(size7)[3]),
                       paste(formula(size8)[3]), 
                       paste(formula(size9)[3]),
                       paste(formula(size10)[3]), 
                       paste(formula(size11)[3]),
                       paste(formula(size12)[3]),
                       paste(formula(size13)[3]),
                       paste(formula(size14.null)[3])),
           AIC = c(sum(AIC(vLG.size.lm)), 
                   sum(AIC(size2)), 
                   sum(AIC(size3)), 
                   sum(AIC(size4)),
                   sum(AIC(size5)), 
                   sum(AIC(size6)),
                   sum(AIC(size7)), 
                   sum(AIC(size8)), 
                   sum(AIC(size9)),
                   sum(AIC(size10)), 
                   sum(AIC(size11)),
                   sum(AIC(size12)), 
                   sum(AIC(size13)), 
                   sum(AIC(size14.null))))
arrange(AIC.vLG.size.traits, AIC)

# all of these models give the same picture. Sal_tannin.PC1 and flavonOLES.PC1 are the best predictors.
summary(size11)
summary(size10)
summary(size12)
summary(size9)

plot(size12) # residuals looks pretty good
vLG.size.predict <- visreg(size12)

# Iteomyia size decreased 1.2 fold over the range in salicylate/tannin chemistry
max(vLG.size.predict$sal_tannin.PC1$y$fit)/min(vLG.size.predict$sal_tannin.PC1$y$fit)

# Iteomyia size decreased 1.2 fold over the range in flavonid chemistry
max(vLG.size.predict$flavonOLES.PC1$y$fit)/min(vLG.size.predict$flavonOLES.PC1$y$fit)

```

```{r gall abund predict}
gall.predict <- predict(manyglm.gall, 
                        newdata = data.frame(Genotype = levels(full.df$Genotype)), 
                        type = "response")
gall.predict.df <- cbind.data.frame(gall.predict, Genotype = levels(full.df$Genotype))
gall.predict.melt <- melt(gall.predict.df)

ggplot(gall.predict.melt, aes(x = Genotype, y = value, fill = variable)) + geom_bar(stat = "identity")

colMeans(gall.predict)
library(vegan)
diversity(colMeans(gall.predict))

gall.predict.X.R <- predict(manyglm.gall, 
                            newdata = data.frame(Genotype = c("X","R")),
                            type = "response")
colMeans(gall.predict.X.R)
diversity(colMeans(gall.predict.X.R))

sample(levels(full.df$Genotype), 5)

names(manyglm.gall$data)
predict.allcombos <- function(manyglm.object, factor.index, predict.type = "response"){
  require(plyr)
  require(dplyr)
  factor.levels <- levels(manyglm.object$data[ ,factor.index])
  
  predict.list <- list()
  for(i in 2:length(factor.levels)){
    tmp.data <- data.frame(sample(factor.levels, i))
    colnames(tmp.data) <- names(manyglm.object$data)[factor.index]
    predict.tmp <- predict(manyglm.object, newdata = tmp.data, type = predict.type)
    predict.list[[i]] <- colMeans(predict.tmp)
  }
  predict.df <- ldply(predict.list) %>%
    mutate(Number.of.Genotypes = 2:length(factor.levels))
}

N <- 50
gall.div.list <- list()
for(i in 1:N){
  gall.div.list[[i]] <- round(predict.allcombos(manyglm.gall, factor.index = 2), 1) # rounding to avoid pseudoaccuracy
} # takes a couple minutes with 50 reps

gall.div.df <- ldply(gall.div.list) %>% tbl_df()
gall.div.df$diversity <- diversity(select(gall.div.df, vLG_abund:SG_abund))

boxplot(diversity ~ factor(Number.of.Genotypes), gall.div.df, ylab = "Gall diversity", xlab = "Number of Genotypes")

N <- 50
link.div.list <- list()
for(i in 1:N){
  link.div.list[[i]] <- round(predict.allcombos(manyglm.full, factor.index = 2), 1)
} # takes a couple minutes with 50 reps

link.div.df <- ldply(link.div.list) %>% tbl_df()
link.div.df$diversity <- diversity(select(link.div.df, aSG_Tory:vLG_Tory))
link.div.df$repID <- 1:dim(link.div.df)[1]

boxplot(diversity ~ factor(Number.of.Genotypes), link.div.df, ylab = "Interaction Diversity", xlab = "Number of Genotypes")

link.melt <- melt(select(link.div.df, -diversity), id.vars = c("repID", "Number.of.Genotypes"))
  
link.split <- colsplit(link.melt$variable, "_", names = c("gall","parasitoid"))
link.melt.df <- cbind(link.melt, link.split)

web.list <- cast(link.melt.df, gall ~ parasitoid | repID + Number.of.Genotypes, mean)

library(bipartite)
web.list.measures <- c()
genotype.number <- c()
for(i in 1:dim(web.list)){
  genotype.number[i] <- names(web.list[[i]][1])
  tmp.web <- web.list[[i]][[1]]
  rownames(tmp.web) <- tmp.web$gall
  tmp.web <- as.matrix.data.frame(tmp.web[ ,-1])
  web.list.measures[i] <- networklevel(tmp.web, index = "linkage density", weighted = TRUE)
}
web.measures.df <- cbind.data.frame(Number.of.Genotypes = as.numeric(genotype.number),
                                    Weighted.Linkage.Density = web.list.measures)

boxplot(Weighted.Linkage.Density ~ factor(Number.of.Genotypes), web.measures.df, ylab = "Weighted Linkage Density", xlab = "Number of Genotypes")

web.measures.summary <- web.measures.df %>%
  group_by(Number.of.Genotypes) %>%
  summarise(median.link.density = median(Weighted.Linkage.Density))
with(web.measures.summary, max(median.link.density)/min(median.link.density))

library(mgcv)
web.sum.lm <- lm(log(median.link.density) ~ log(Number.of.Genotypes), data = web.measures.summary)
summary(web.sum.lm) # Need to understand interpretation here.
visreg(web.sum.lm) # not quite there
```



We were unable to use the mvabund framework for this analysis, so we conducted separate linear models to test for these effects.
```{r gall size}
plot(vLG.height.mean ~ Genotype, full.df)
vLG.size.lm <- lm(log(vLG.height.mean) ~ Genotype, filter(full.df, Genotype != "J"))
#plot(vLG.size.lm)
summary(vLG.size.lm)

vLG.size.lmer <- lmer(log(vLG.height.mean) ~ (1|Genotype), full.df)
heritability(vLG.size.lmer) # significant. Note though, that I originally valuate gall size using nested random effect models to account for individual measurements I had for each gall.

plot(rG.height.mean ~ Genotype, full.df)
rG.size.lm <- lm(log(rG.height.mean) ~ Genotype, full.df)
#plot(rG.size.lm)
summary(rG.size.lm)

plot(aSG.height.mean ~ Genotype, full.df) # too few data points to reliably evaluate
aSG.size.lm <- lm(log(aSG.height.mean) ~ Genotype, full.df)
#plot(aSG.size.lm)
summary(aSG.size.lm)

plot(SG.height.mean ~ Genotype, full.df) # too few data points to reliably evaluate
SG.size.lm <- lm(log(SG.height.mean) ~ Genotype, full.df)
plot(SG.size.lm)
summary(SG.size.lm)
```

```{r gall size variation among willow genotypes}
vLG.height.mean.plot <- ggplot(data = full.df, aes(x = Genotype, y = vLG.height.mean)) + 
  geom_boxplot() + ylab("Iteomyia salicisverruca diameter (mm)")
rG.height.mean.plot <- ggplot(data = full.df, aes(x = Genotype, y = rG.height.mean)) + 
  geom_boxplot() + ylab("Rabdophaga salicisbrassicoides diameter (mm)")
aSG.height.mean.plot <- ggplot(data = full.df, aes(x = Genotype, y = aSG.height.mean)) + 
  geom_boxplot() + ylab("Cecidomyid sp. A diameter (mm)")
SG.height.mean.plot <- ggplot(data = full.df, aes(x = Genotype, y = SG.height.mean)) + 
  geom_boxplot() + ylab("Rabdophaga salicisbattatus diameter (mm)")

grid.arrange(vLG.height.mean.plot, rG.height.mean.plot, aSG.height.mean.plot, SG.height.mean.plot)
```

Here, we evaluate the assumptions of mvabund and see which error distribution is appropriate. Specifically, we first look at a plot of the mean-variance relationship of our response variables. It is easy to see that the negative binomial model (black line) provides the best fit to this data, suggesting that we should specify this as the error distribution in our model
```{r mv abund interactions explore}
full.mvabund <- mvabund(full.df[ ,interaxns_noPont]) # create mvabund object for easy analysis
meanvar.plot(full.mvabund ~ full.df$Genotype) # easy to see that the data do not have a poisson distribution, therefore, a negative binomial may be a good fit.
poisson_curve(from = 0.1, to = 3.0, color = "blue")
quasipoisson_curve(from = 0.1, to = 3.0, quasi.scalar = 2, color = "red")
neg.binomial_curve(from = 0.1, to = 3.0, theta.negbin = 0.7, color = "black") # negative binomial appears to provide the best fit to this relationship
```

```{r genotype level}
geno.level.interactions.df <- full.df %>%
  select(Genotype, aSG_Tory:rG_Platy, rG_Tory, SG_Platy, vLG_Eulo:vLG_Tory, aSG_abund:vLG_abund, vLG.height.mean) %>%
  group_by(Genotype) %>%
  summarise_each(funs(mean.na.rm = mean(., na.rm = TRUE))) %>%
  #na.omit() %>%
  mutate(log.vLG_abund = log(vLG_abund),
         log.vLG.height.mean = log(vLG.height.mean),
         log.1.rG_abund = log(rG_abund+1),
         log.1.aSG_abund = log(aSG_abund+1))

library(psych)
corr.test(geno.level.interactions.df[ ,c("vLG_abund","rG_abund","aSG_abund","vLG.height.mean")])

car::scatterplotMatrix(select(geno.level.interactions.df, vLG_abund, rG_abund, aSG_abund, vLG.height.mean))
corr.test(geno.level.interactions.df[ ,c("log.vLG_abund","log.1.rG_abund","log.1.aSG_abund","log.vLG.height.mean")])

# correlations are rather weak
corr.test(select(geno.level.interactions.df, aSG_Tory:vLG_Tory))
corr.test(select(geno.level.interactions.df, vLG_Platy, vLG_Mesopol, vLG_Tory, rG_Tory))
car::scatterplotMatrix(select(geno.level.interactions.df, vLG_Platy, vLG_Mesopol, vLG_Tory, rG_Tory))

plot(rG_Eulo ~ vLG_Mymarid, geno.level.interactions.df)

plot(log.1.aSG_abund ~ log.vLG_abund, geno.level.interactions.df)

geno.level.mvabund <- mvabund(geno.level.interactions.df[ ,interaxns_noPont])

geno.level.manyglm <- manylm(geno.level.mvabund ~ vLG_abund*vLG.height.mean + rG_abund + aSG_abund, data = geno.level.interactions.df)

plot(geno.level.manyglm, which = 1:3)
anova.manylm(geno.level.manyglm, p.uni = "unadjusted")

hist(geno.level.interactions.df$vLG_Platy)
plot(vLG_Mesopol ~ vLG.height.mean, geno.level.interactions.df)
vLG_Platy.lm <- lm(vLG_Mesopol ~ vLG_abund+vLG.height.mean, geno.level.interactions.df)
summary(vLG_Platy.lm)
plot(vLG_Platy.lm)
AIC(vLG_Platy.lm)
library(visreg)
visreg(vLG_Platy.lm, scale = "response")
```

We then fit a model and used residual plots to diagnose the model fit.
```{r mv abund negative binomial assumptions}
manyglm.full <- manyglm(full.mvabund ~ Genotype,
                          data = full.df,
                          family = "negative.binomial")
plot(manyglm.full, which = 1:3) # residuals aren't quite normally distributed, but there doesn't seem to be any heteroscedasticity in the model fit. Note that replotting the residuals gives qualitatively the same picture (it's important to replot them because the residuals involve random number generation, see ?plot.manyglm)
```

```{r}
link.predict <- predict(manyglm.full, 
                        newdata = data.frame(Genotype = levels(full.df$Genotype)), 
                        type = "response")
link.predict.df <- cbind.data.frame(link.predict, Genotype = levels(full.df$Genotype))
library(vegan)
mean(vegdist(select(link.predict.df, -Genotype), method = "horn"))
sd(vegdist(select(link.predict.df, -Genotype), method = "horn"))
hist(vegdist(select(link.predict.df, -Genotype), method = "horn"))

link.predict.melt <- melt(link.predict.df)

ggplot(link.predict.melt, aes(x = Genotype, y = value, fill = variable)) + geom_bar(stat = "identity")
```

Given that a negative binomial distribution seems to provide a good fit to the data, we tested whether the composition of gall-parasitoid interaction varied among willow genotypes. To further diagnose which interactions were driving this response, we conducted univariate analyses on each predictor, but adjusted for multiple comparisons. P-values were adjusted for multiple testing using a step-down resampling procedure. This methods provides strong control of family-wise error rates and makes use of resampling to ensure inferences take into account correlation between variables (Westfall & Young 1993).

From the table, it is clear to say that genotype has a strong effect on the composition of links in the network. Moreover, differences in community composition are driven primarily by 3 interactions: vLG_Platy, vLG_Tory, and vLG_Mesopol.
```{r}
anova.full <- anova.manyglm(manyglm.full, p.uni = "unadjusted") # Takes about 1 min and 30 sec to run.
anova.full # vLG_Platy, vLG_Tory, and vLG_Mesopol are driving the community response. rG_Tory is marginally significant and vLG_Eulo is close to marginal as well.
```

Now we examine how variation in gall densities and gall size (for Iteomyia) affects the network.

First we created a dataset that contained complete observations of the network and predictor variables
```{r mv abund interaction predictors}
full.predictors <- full.df %>%
  select(aSG_Tory:rG_Platy, rG_Tory, SG_Platy, vLG_Eulo:vLG_Tory, # interactions
         aSG_abund:vLG_abund, # gall counts. Exclusing SG_abund because it didn't vary among genotypes
         vLG.height.mean) %>% # Iteomyia gall size
# we transformed some of the variables so we could examine their vif 
  mutate(log.vLG_abund = log(vLG_abund),
         log.1.vLG_abund = log(vLG_abund + 1),
         log.1.rG_abund = log(rG_abund + 1),
         log.1.aSG_abund = log(aSG_abund + 1),
         log.vLG.height.mean = log(vLG.height.mean)) %>%
  na.omit() # removes all instances that don't have vLG.height.mean
dim(full.predictors)[1] # 81 data points
```

We then looked for evidence of variance inflation among the predictor variables. But found little evidence for it.
```{r vif}
vif(full.predictors[ ,c("log.1.aSG_abund","log.1.rG_abund","log.vLG_abund","log.vLG.height.mean")]) # still little evidence of variance inflation among predictor variables.
```

We log transformed all predictor variables because it provided a much better fit to the data as determined by AIC. We then used AIC to compare our most complex model to our least complex. Instead of exploring all possible combinations, we started with the most complex model and used AIC to drop predictor variables with the lowest AIC values (i.e. least impact on removal). Using AIC, we identified 3 equivalenet models (difference in AIC < 2.1 amongst models). 
```{r AIC model assessment}
net.trait <- mvabund(full.predictors[ ,interaxns_noPont])
net.trait.sub <- mvabund(full.predictors[ ,c("vLG_Platy","vLG_Mesopol","vLG_Tory","rG_Tory")])
# even though manyglm doesn't appear to test interaction terms appropriately (sequential vs. dropping different terms), there is not interactive effect of vLG height and vLG abundance in univariate negative binomial models for any vLG_parasitoid interaction, so I believe this final model is appropriate for the data.
net.mvabund.1.full <- manyglm(net.trait ~ log.vLG_abund*vLG.height.mean + 
                         log.1.rG_abund + log.1.aSG_abund,
                       data = full.predictors,
                       family = "negative.binomial")
MASS::stepAIC(net.mvabund.1.full, direction = "both")

net.mvabund.2 <- update(net.mvabund.1.full, .~. - log.vLG_abund:vLG.height.mean)

drop1(net.mvabund.2)
net.mvabund.3 <- update(net.mvabund.2, .~. - vLG.height.mean)

drop1(net.mvabund.3)
net.mvabund.4 <- update(net.mvabund.3, .~. - log.1.aSG_abund)

drop1(net.mvabund.4)
net.mvabund.5 <- update(net.mvabund.4, .~. - log.vLG_abund)

drop1(net.mvabund.5)
net.mvabund.6.null <- update(net.mvabund.5, .~. -log.1.rG_abund)

AIC.models <- data.frame(Model = 1:6, # progressive order in which models were fit
           Formula = c(paste(formula(net.mvabund.1.full)[3]), 
                       paste(formula(net.mvabund.2)[3]),
                       paste(formula(net.mvabund.3)[3]), 
                       paste(formula(net.mvabund.4)[3]),
                       paste(formula(net.mvabund.5)[3]), 
                       paste(formula(net.mvabund.6.null)[3])),
           AIC = c(sum(AIC(net.mvabund.1.full)), 
                   sum(AIC(net.mvabund.2)), 
                   sum(AIC(net.mvabund.3)), 
                   sum(AIC(net.mvabund.4)),
                   sum(AIC(net.mvabund.5)), 
                   sum(AIC(net.mvabund.6.null))))
arrange(AIC.models, AIC)

anova.manyglm(net.mvabund.1.full, net.mvabund.2, net.mvabund.3, net.mvabund.4, net.mvabund.5, net.mvabund.6.null) # takes about 3 min to run.
```

After deciding on the model with all main effects and no interactions, we examined the residuals and everything looked pretty good.
```{r}
plot(net.mvabund.2, which = 1:3) # residuals look pretty good.
```

We then examined the which processes underlied variation in the gall-parasitoid interactions.
```{r}
anova.net <- anova.manyglm(net.mvabund.2, p.uni = "unadjusted") # takes about 2.5 min to run.
anova.net # not that since the P-values are determined by a resampling procedure, they may differ slightly between runs. Therefore, we retain all P-values < 0.10 (during at least one run) for the coefficient summary below. 

sig.coef.df.2 <- mutate(melt(coef(net.mvabund.2)),
               predictor_response = paste(X1, X2, sep = "_")) %>%
 # select(predictor = X1, response = X2, predictor_response, value) %>%
  subset(predictor_response %in% c("log.1.aSG_abund_aSG_Tory", 
                                 "log.1.rG_abund_rG_Eulo",
                                 "log.1.rG_abund_rG_Platy",
                                 "log.1.rG_abund_rG_Lestodip", # marginal
                                 "log.vLG_abund_SG_Platy", # marginal
                                 "log.vLG_abund_vLG_Mymarid",
                                 "log.vLG.height.mean_vLG_Eulo", # marginal
                                 "log.vLG.height.mean_rG_Tory", "log.1.rG_abund_rG_Tory",
                                 "log.vLG_abund_vLG_Mesopol", "log.vLG.height.mean_vLG_Mesopol", 
                                 "log.vLG.height.mean_vLG_Platy", "log.vLG_abund_vLG_Platy",
                                 "log.vLG.height.mean_vLG_Tory", "log.vLG_abund_vLG_Tory")) %>% # vLG.height.mean is marginal for vLG_Tory
  select(predictor = X1, response = X2, coefficient = value)
arrange(sig.coef.df.2, predictor, response)
```


```{r Interaction predictions}
# calculate the mean values, on the original scale, of all predictor variables
no.var.data <- with(full.predictors,
                    data.frame(vLG_abund = mean(vLG_abund),
                               rG_abund = mean(rG_abund),
                               aSG_abund = mean(aSG_abund),
                               vLG.height.mean = mean(vLG.height.mean)))

# http://www.ats.ucla.edu/stat/mult_pkg/faq/general/log_transformed_regression.htm Use this web page for interpreting log and non-transformed coefficients in regression.
library(visreg)
par(mfrow = c(1,2))
vLG_Platy.glm <- MASS::glm.nb(vLG_Platy ~ log(vLG_abund) + vLG.height.mean, full.predictors); summary(vLG_Platy.glm); jensen_magnitude(vLG_Platy.glm, no.var.data)
visreg(vLG_Platy.glm, scale = "response")
#plot(vLG_Platy.glm)

vLG_Mesopol.glm <- MASS::glm.nb(vLG_Mesopol ~ log(vLG_abund) + vLG.height.mean, full.predictors); summary(vLG_Mesopol.glm); jensen_magnitude(vLG_Mesopol.glm, no.var.data)
#plot(vLG_Mesopol.glm)
visreg(vLG_Mesopol.glm, scale = "response")

vLG_Tory.glm <- MASS::glm.nb(vLG_Tory ~ vLG_abund+vLG.height.mean, full.predictors); summary(vLG_Tory.glm); jensen_magnitude(vLG_Tory.glm, no.var.data) # gall height is marginally significant, but the AIC is slightly better than the model with only vLG_abund.
visreg(vLG_Tory.glm, scale = "response")

rG_Tory.glm <- glm(rG_Tory ~ rG_abund + vLG.height.mean, full.predictors, family = quasipoisson); summary(rG_Tory.glm); jensen_magnitude(rG_Tory.glm, no.var.data) # underdispersed, which is why I used quasipoisson.
#plot(rG_Tory.glm)
visreg(rG_Tory.glm, scale = "response")

rG_Platy.glm <- glm(rG_Platy ~ rG_abund, full.predictors, family = quasipoisson); summary(rG_Platy.glm); jensen_magnitude(rG_Platy.glm, no.var.data)  # underdispersed, which is why I used quasipoisson.

rG_Eulo.glm <- glm(rG_Eulo ~ rG_abund, full.predictors, family = quasipoisson); summary(rG_Eulo.glm); jensen_magnitude(rG_Eulo.glm, no.var.data) # underdispersed, which is why I used quasipoisson

aSG_Tory.glm <- glm(aSG_Tory ~ aSG_abund, full.predictors, family = quasipoisson); summary(aSG_Tory.glm); jensen_magnitude(aSG_Tory.glm, no.var.data) # underdispersed, so I used quasipoisson. 

rG_Lestodip.glm <- glm(rG_Lestodip ~ log(rG_abund + 1), full.predictors, family = quasipoisson)
summary(rG_Lestodip.glm); jensen_magnitude(rG_Lestodip.glm, no.var.data) # rG_abund is marginally significant.

## intercept only models.
vLG_Eulo.glm <- glm(vLG_Eulo ~ 1, full.predictors, family = poisson); summary(vLG_Eulo.glm); jensen_magnitude(vLG_Eulo.glm, no.var.data) # not a lot of support for including gall height as a predictor, althought it was marginally significant in multivariate model, so I dropped it from the model

SG_Platy.glm <- glm(SG_Platy ~ 1, full.predictors, family = poisson); summary(SG_Platy.glm); jensen_magnitude(SG_Platy.glm, no.var.data) # no evidence of vLG_abund being a clear predictor, so we dropped it from the model

rG_Mesopol.glm <- glm(rG_Mesopol ~ 1, full.predictors, family = poisson); summary(rG_Mesopol.glm); jensen_magnitude(rG_Mesopol.glm, no.var.data)

vLG_Mymarid.glm <- glm(vLG_Mymarid ~ 1, full.predictors, family = poisson); summary(vLG_Mymarid.glm); jensen_magnitude(vLG_Mymarid.glm, no.var.data) # vLG_abund is a significant predictor, but the visreg predictions look so wonky that I don't really trust it, so I just modelled it with an intercept
```

```{r visreg plots}
# Platygaster interactions
layout(matrix(c(1, 2, 3, 4), nrow = 2, ncol = 2, byrow = FALSE))
visreg(vLG_Platy.glm, scale = "response", ask = F)
plot(x = range(full.predictors$vLG_abund), y = c(0, 1), type = "n", ylab = "SG_Platy", xlab = "vLG_abund"); abline(h = exp(coef(SG_Platy.glm)), col = "steelblue", lwd = 3) # intercept only models
visreg(rG_Platy.glm, scale = "response", ask = F)

# Mesopolobus interactions
layout(matrix(c(1, 2, 3, 0), nrow = 2, ncol = 2, byrow = FALSE))
visreg(vLG_Mesopol.glm, scale = "response", ask = F)
plot(x = range(full.predictors$rG_abund), y = c(0, 1), type = "n", ylab = "rG_Mesopol", xlab = "rG_abund"); abline(h = exp(coef(rG_Mesopol.glm)), col = "steelblue", lwd = 3) # intercept only models

# Torymus interactions
layout(matrix(c(1, 2, 3, 4, 5, 0), nrow = 2, ncol = 3, byrow = FALSE))
visreg(vLG_Tory.glm, scale = "response", ask = F)
visreg(rG_Tory.glm, scale = "response", ask = F)
visreg(aSG_Tory.glm, scale = "response", ask = F)

# Eulophid interactions and other less abundant ones
layout(matrix(c(1, 2, 3, 4), nrow = 2, ncol = 2, byrow = FALSE))
plot(x = range(full.predictors$vLG_abund), y = c(0, 1), type = "n", ylab = "vLG_Eulo", xlab = "vLG_abund"); abline(h = exp(coef(vLG_Eulo.glm)), col = "steelblue", lwd = 3)
visreg(rG_Eulo.glm, scale = "response", ask = F)
plot(x = range(full.predictors$vLG_abund), y = c(0, 1), type = "n", ylab = "vLG_Mymarid", xlab = "vLG_abund"); abline(h = exp(coef(vLG_Mymarid.glm)), col = "steelblue", lwd = 3)
visreg(rG_Lestodip.glm, scale = "response", ask = F)

par(mfrow = c(1,1))
```

```{r table of jensen effects}
jensen.df <- rbind_all(list(jensen_magnitude(vLG_Platy.glm, no.var.data),
               jensen_magnitude(vLG_Mesopol.glm, no.var.data),
               jensen_magnitude(vLG_Tory.glm, no.var.data),
               jensen_magnitude(vLG_Eulo.glm, no.var.data),
               jensen_magnitude(vLG_Mymarid.glm, no.var.data),
               jensen_magnitude(rG_Tory.glm, no.var.data),
               jensen_magnitude(rG_Mesopol.glm, no.var.data),
               jensen_magnitude(rG_Platy.glm, no.var.data),
               jensen_magnitude(rG_Mesopol.glm, no.var.data),
               jensen_magnitude(rG_Lestodip.glm, no.var.data),
               jensen_magnitude(aSG_Tory.glm, no.var.data),
               jensen_magnitude(SG_Platy.glm, no.var.data)))
jensen.df <- mutate(jensen.df, Interactions = c("vLG_Platy","vLG_Mesopol","vLG_Tory","vLG_Eulo","vLG_Mymarid","rG_Tory","rG_Mesopol","rG_Platy","rG_Mesopol","rG_Lestodip","aSG_Tory","SG_Platy"))
plot(log(Magnitude.Difference) ~ log(mean.no.var), filter(jensen.df, Magnitude.Difference != "1"))
visreg(lm(log(Magnitude.Difference) ~ log(mean.no.var), filter(jensen.df, Magnitude.Difference != "1")), scale = "response", xtrans = log, xlab = "log(mean.no.var)")

interactions.split <- colsplit(jensen.df$Interactions, "_", names = c("gall","parasitoid"))
jensen.df <- cbind(jensen.df, interactions.split)

var.web <- cast(jensen.df, gall ~ parasitoid, mean, value = "mean.with.var")
rownames(var.web) <- var.web$gall
var.web <- as.matrix.data.frame(var.web[ ,-1])

no.var.web <- cast(jensen.df, gall ~ parasitoid, mean, value = "mean.no.var")
rownames(no.var.web) <- no.var.web$gall
no.var.web <- as.matrix.data.frame(no.var.web[ ,-1])

library(bipartite)
plotweb(var.web, method = "normal")
plotweb(no.var.web, method = "normal")
```

```{r remove weak interactions}
colSums(full.predictors[ ,interaxns_noPont]) # remove rG_Lestodip, rG_Mesopol, vLG_Mymarid, and SG_Platy. SG_Platy had 9 interactions, but all of these interactions came from a single, multichambered gall.

net.trait.noweak <- mvabund(full.predictors[ ,c("aSG_Tory", "rG_Eulo", "rG_Tory", "vLG_Eulo", "vLG_Mesopol","vLG_Platy", "vLG_Tory")])

net.mvabund.2.noweak <- manyglm(net.trait.noweak ~ log.vLG_abund + log.vLG.height.mean + 
                         log.1.rG_abund + log.1.aSG_abund,
                       data = full.predictors,
                       family = "negative.binomial")
```

```{r}
## Identify the effect of phenotypic variation (gall density and gall size) on food web structure

## create data with the same mean, but NO VARIANCE in predictor variables. For some reason, the predict.manyglm needs a dataset that is the same dimension as the original one.
row.count <- dim(full.predictors)[1]
no.var.data <- with(full.predictors, 
                  data.frame(log.vLG_abund = rep(log(mean(vLG_abund)), row.count),
                             log.1.rG_abund = rep(log(mean(rG_abund)+1), row.count),
                             log.1.aSG_abund = rep(log(mean(aSG_abund)+1), row.count),
                             log.vLG.height.mean = rep(log(mean(vLG.height.mean)), row.count)))
# increase mean by one standard deviation. With this type of code, I should be able to make predictions for how evolution will affect the food web.
no.var.data.vLG.size.Increase <- with(full.predictors, 
                  data.frame(log.vLG_abund = rep(log(mean(vLG_abund)), row.count),
                             log.1.rG_abund = rep(log(mean(rG_abund)+1), row.count),
                             log.1.aSG_abund = rep(log(mean(aSG_abund)+1), row.count),
                             log.vLG.height.mean = rep(log(mean(vLG.height.mean)+sd(vLG.height.mean)), row.count)))

jensen.net.mvabund.2 <- jensen_magnitude_manyglm(net.mvabund.2, original.data = full.predictors,
                                                 comparison.data = no.var.data)
jensen.net.mvabund.2.noweak <- jensen_magnitude_manyglm(net.mvabund.2.noweak, original.data = full.predictors, comparison.data = no.var.data)
jensen.net.mvabund.2.meanIncrease <- jensen_magnitude_manyglm(net.mvabund.2, original.data = no.var.data, comparison.data = no.var.data.vLG.size.Increase)

# used a wilcoxon signed rank test because the differences were not normally distributed
with(jensen.net.mvabund.2, hist(var.predict - no.var.predict, breaks = seq(0,2,0.01)))
with(jensen.net.mvabund.2, wilcox.test(var.predict, no.var.predict, 
                                       paired = TRUE, conf.int = TRUE))
magnitude.lm <- lm(log(Percent.Difference) ~ log(no.var.predict), jensen.net.mvabund.2)
summary(magnitude.lm); visreg(magnitude.lm, scale = "response", xtrans = log)

# I get the same qualitative results even after removing the weakest interactions from the dataset
with(jensen.net.mvabund.2.noweak, wilcox.test(var.predict, no.var.predict, 
                                              paired = TRUE, conf.int = TRUE)) 
magnitude.lm.noweak <- lm(log(Percent.Difference) ~ log(no.var.predict), 
                          jensen.net.mvabund.2.noweak)
summary(magnitude.lm.noweak); visreg(magnitude.lm.noweak, scale = "response", xtrans = log)
```

```{r effects of variation on food web structure}
library(bipartite)
jensen.to.use <- jensen.net.mvabund.2.noweak
interactions.split <- colsplit(jensen.to.use$response.variables, 
                               "_", names = c("gall","parasitoid"))
jensen.to.use <- cbind(jensen.to.use, interactions.split)

var.web <- cast(jensen.to.use, gall ~ parasitoid, mean, value = "var.predict")
rownames(var.web) <- var.web$gall
var.web <- as.matrix.data.frame(var.web[ ,-1])

no.var.web <- cast(jensen.to.use, gall ~ parasitoid, mean, value = "no.var.predict")
rownames(no.var.web) <- no.var.web$gall
no.var.web <- as.matrix.data.frame(no.var.web[ ,-1])

par(mfrow = c(2,1))
plotweb(var.web, method = "normal")
plotweb(no.var.web, method = "normal")

cbind(networklevel(var.web, 
                   index = c("linkage density", "interaction evenness")),
      networklevel(no.var.web,
                   index = c("linkage density", "interaction evenness")))
```

```{r}
vLG.ptized.glm <- glm(cbind(vLG_parasitized, vLG_abund - vLG_parasitized) ~ vLG.height.mean, full.df, family = binomial)
summary(vLG.ptized.glm)
visreg(vLG.ptized.glm, scale = "response")
vLG.ptized.no.var.data <- with(full.predictors, data.frame(vLG.height.mean = mean(vLG.height.mean)))
jensen_magnitude(vLG.ptized.glm, no.var.data = vLG.ptized.no.var.data)
#plot(vLG.ptized.glm)

vLG.Platy.glm <- glm(cbind(vLG_Platy, vLG_abund - vLG_Platy) ~ vLG.height.mean, full.df, family = binomial)
summary(vLG.Platy.glm)
visreg(vLG.Platy.glm, scale = "response")
vLG.Platy.no.var.data <- with(full.predictors, data.frame(vLG.height.mean = mean(vLG.height.mean)))
jensen_magnitude(vLG.Platy.glm, no.var.data = vLG.Platy.no.var.data)

vLG.Tory.glm <- glm(cbind(vLG_Tory, vLG_abund - vLG_Tory) ~ vLG.height.mean, full.df, family = binomial)
summary(vLG.Tory.glm)
visreg(vLG.Tory.glm, scale = "response")
vLG.Tory.no.var.data <- with(full.predictors, data.frame(vLG.height.mean = mean(vLG.height.mean)))
jensen_magnitude(vLG.Tory.glm, no.var.data = vLG.Tory.no.var.data)

#plot(vLG_Platy ~ Genotype, full.df)
#plot(vLG_Tory ~ Genotype, full.df)

vLG.ptized.glmer <- glmer(cbind(vLG_parasitized, vLG_abund - vLG_parasitized) ~ log(vLG.height.mean) + (1|Genotype), full.df, family = binomial)
summary(vLG.ptized.glmer)
visreg(vLG.ptized.glmer, scale = "response")
mean(predict(vLG.ptized.glmer, type = "response"))
#mean(predict(vLG.ptized.glmer, newdata = vLG.ptized.no.var.data, type = "response"))

vLG_Platy.glmer <- glmer(vLG_Platy ~ log(vLG_abund) + log(vLG.height.mean) + (1|Genotype), full.df, family = poisson)
summary(vLG_Platy.glmer)
overdisp_fun(vLG_Platy.glmer) # no overdispersion when I model genotype as a randome effect.
visreg(vLG_Platy.glmer, scale = "response")
```

```{r}
## Examine whether the proportion of galls parasitized varies among willow genotypes

## vLG parasitism
vLG.ptized.df <- full.df %>%
  filter(vLG_abund > 0)
table(vLG.ptized.df$Genotype)
vLG.ptized.3plus.genos <- c("*","B","D","E","F","H","I","K","L","O","S","V","X","Y","Z")
colSums(vLG.ptized.df[ ,c("vLG_parasitized","vLG_abund","vLG_Tory","vLG_Eulo","vLG_Platy",
                         "vLG_Mesopol","vLG_Mymarid")])

# interesting, only marginally significant with quasibinomial
vLG.ptized.bin <- glm(cbind(vLG_parasitized, vLG_abund - vLG_parasitized) ~ Genotype,
                  data = filter(vLG.ptized.df, Genotype %in% vLG.ptized.3plus.genos), 
                  family = 'binomial')
anova(glm.binomial.disp(vLG.ptized.bin), test = "LR") # just significant, when I account for overdispersion using this method...

vLG.ptized.bin.glmer <- glmer(cbind(vLG_parasitized, vLG_abund - vLG_parasitized) ~ (1|Genotype),
                  data = filter(vLG.ptized.df, Genotype %in% vLG.ptized.3plus.genos), 
                  family = 'binomial')
overdisp_fun(vLG.ptized.bin.glmer)

test.2 <- rpt.binomGLMM.add(y = with(vLG.ptized.df, cbind(vLG_parasitized, vLG_abund - vLG_parasitized)), groups = vLG.ptized.df$Genotype) 
test.2
library(emdbook)
library(MASS)
vLG.ptized.df <- mutate(vLG.ptized.df, 
                        plant.position = factor(plant.position))
library(lme4)
sc.abund <- scale(vLG.ptized.df$vLG_abund)
sc.height <- scale(vLG.ptized.df$vLG.height.mean)
test.4 <- glmer(cbind(vLG_parasitized, vLG_abund - vLG_parasitized) ~  vLG.height.mean + (1|Genotype),
                  data = vLG.ptized.df,
                  family = 'binomial')
summary(test.4)
AIC(test.4)
confint(test.4, method = "profile") # variance > 0!
overdisp_fun(test.4) # no clear evidence of overdispersion
ggQQ_ranef(ranef(test.4)$Genotype$'(Intercept)') # and the residuals look great!
visreg(test.4, scale = "response")
R.link  <- .6411 / (.6411 +pi^2 /3) # heritability is reasonable as well
R.link.low  <- .1153673 / (.1153673 +pi^2 /3) 
R.link.high  <- 1.44 / (1.44 +pi^2 /3) 
profile(test.4, which = 1)
summary(test.4)
test.3 <- rpt.binomGLMM.multi(y = with(vLG.ptized.df, cbind(vLG_parasitized, vLG_abund - vLG_parasitized)), groups = vLG.ptized.df$Genotype) 

library(RLRsim)

#plot(vLG.ptized.bin)
summary(vLG.ptized.bin)
dfun(vLG.ptized.bin)
anova(vLG.ptized.bin, test = "LR") # still significant after retaining Genotypes with 3 plus replicates.

vLG_ptized.bin.pred <- gam(cbind(vLG_parasitized, vLG_abund - vLG_parasitized) ~ s(vLG.height.mean),
                  data = full.df, 
                  family = 'binomial')
summary(vLG_ptized.bin.pred)
AIC(vLG_ptized.bin.pred)
visreg(vLG_ptized.bin.pred, scale = "response")
#jensen.single(vLG_ptized.bin.pred)

# vLG_Platy test
vLG_Platy.bin <- glm(cbind(vLG_Platy, vLG_abund - vLG_Platy) ~ Genotype,
                  data = filter(full.df, Genotype %in% vLG.ptized.3plus.genos), 
                  family = 'quasibinomial')
plot(vLG_Platy.bin)
summary(vLG_Platy.bin)
anova(vLG_Platy.bin, test = "F")

library(dispmod)
vLG_Platy.bin.pred <- glm(cbind(vLG_Platy, vLG_abund - vLG_Platy) ~ vLG.height.mean,
                  data = full.predictors, 
                  family = 'binomial')
dfun(vLG_Platy.bin.pred)
summary(vLG_Platy.bin.pred)
glm.binomial.disp(vLG_Platy.bin.pred)
AIC(vLG_Platy.bin.pred)
plot(vLG_Platy.bin.pred)
visreg(vLG_Platy.bin.pred, scale = "response")
jensen.single(vLG_Platy.bin.pred)
glm.binomial.disp(vLG_Platy.bin.pred)
qAIC(vLG_Platy.bin.pred, dispersion = dfun(vLG_Platy.bin.pred))

dfun(vLG_Platy.bin.pred)

vLG_Platy.bin.pred.glmer <- glmer(cbind(vLG_Platy, vLG_abund - vLG_Platy) ~ vLG.height.mean + (1|Genotype),
                  data = full.df, 
                  family = 'binomial')
summary(vLG_Platy.bin.pred.glmer)
overdisp_fun(vLG_Platy.bin.pred.glmer)
AIC(vLG_Platy.bin.pred.glmer)
plot(vLG_Platy.bin.pred.glmer)
ggQQ_ranef(ranef(vLG_Platy.bin.pred.glmer)$Genotype$'(Intercept)') # not too bad.

# AIC gam interaction 207.6398, AIC = 204 with main effect model in gam. 213 with main model

## Identify the effect of phenotypic variation (gall density and gall size) on food web structure

jensen.single(final.vLG_Platy)
jensen.single(vLG_Mesopol.bin.pred)
jensen.single(vLG_Tory.bin.pred)

# vLG_Mesopol test
vLG_Mesopol.bin <- glm(cbind(vLG_Mesopol, vLG_abund - vLG_Mesopol) ~ Genotype,
                  data = filter(full.df, Genotype %in% vLG.ptized.3plus.genos), 
                  family = 'binomial')
plot(vLG_Mesopol.bin)
summary(vLG_Mesopol.bin)
dfun(vLG_Mesopol.bin)
anova(vLG_Mesopol.bin, test = "LR")

vLG_Mesopol.bin.pred <- gam(cbind(vLG_Mesopol, vLG_abund - vLG_Mesopol) ~ vLG.height.mean,
                  data = full.df, 
                  family = 'quasibinomial')
summary(vLG_Mesopol.bin.pred)
visreg(vLG_Mesopol.bin.pred, xvar = "vLG.height.mean", scale = "response")
dfun(vLG_Mesopol.bin.pred)

jensen.single(vLG_Mesopol.bin.pred)

# vLG_Tory test
vLG_Tory.bin <- glm(cbind(vLG_Tory, vLG_abund - vLG_Tory) ~ Genotype,
                  data = filter(full.df, Genotype %in% vLG.ptized.3plus.genos), 
                  family = 'binomial')
plot(vLG_Tory.bin)
summary(vLG_Tory.bin)
anova(vLG_Tory.bin, test = "LR")

vLG_Tory.bin.pred <- glm(cbind(vLG_Tory, vLG_abund - vLG_Tory) ~ vLG_abund + vLG.height.mean,
                  data = full.df, 
                  family = 'binomial')
summary(vLG_Tory.bin.pred)
AIC(vLG_Tory.bin.pred) # 136.1538 is the lowest score. Main effect model
visreg(vLG_Tory.bin.pred, scale = "response")

# vLG_Eulo test
vLG_Eulo.bin <- glm(cbind(vLG_Eulo, vLG_abund - vLG_Eulo) ~ Genotype,
                  data = filter(full.df, Genotype %in% vLG.ptized.3plus.genos), 
                  family = 'binomial')
#plot(vLG_Eulo.bin)
summary(vLG_Eulo.bin)
anova(vLG_Eulo.bin, test = "LR") # not significant

# not testing vLG_Mymarid because it is in such low abundance
predict.df <- data.frame(Genotype = vLG.ptized.3plus.genos)
vLG.genotype.predictions <- cbind.data.frame(predict.df, 
                                         vLG.Proportion.Ptized = predict(vLG.ptized.bin,
                                                                               newdata = predict.df,
                                                                               type = "response"))
summary(vLG.genotype.predictions)

ggplot(filter(vLG.ptized.df, Genotype %in% vLG.ptized.3plus.genos),
       aes(x = Genotype, y = vLG_parasitized/vLG_abund)) +
  geom_point(aes(size = vLG_abund), color = "grey", shape = 1,
             position = position_jitter(height = 0, width = 0.1)) + 
  scale_size(range = c(3,15)) + 
  geom_point(data = vLG.genotype.predictions, 
             aes(x = Genotype, y = vLG.Proportion.Ptized),
             color = "steelblue", size = 30, shape = "--") +
  theme_classic() +
  ylab("Proportion of galls parasitized")
range(filter(vLG.ptized.df, Genotype %in% vLG.ptized.3plus.genos)$vLG_abund)

## rG parasitism
rG.ptized.df <- full.df %>%
  filter(rG_abund > 0)
table(rG.ptized.df$Genotype)
rG.ptized.3plus.genos <- c("*","A","D", "F", "G", "H","I","K","O","Q", "R", "S","X", "Y", "Z") 
colSums(rG.ptized.df[ ,c("rG_parasitized","rG_abund","rG_Tory","rG_Eulo","rG_Platy",
                         "rG_Mesopol","rG_Lestodip")]) # too few rG_eulo, rG_Platy, rG_Mesopol, and rG_Lestodip to test for differences in parasitism among genotypes.

rG.ptized.bin <- glm(cbind(rG_parasitized, rG_abund - rG_parasitized) ~ Genotype,
                  data = filter(full.df, Genotype %in% rG.ptized.3plus.genos), 
                  family = 'binomial')
#plot(rG.ptized.bin) # residuals not great
summary(rG.ptized.bin)
anova(rG.ptized.bin, test = "LR") # marginally significant after retaining Genotypes with 3 plus replicates.

# rG_Tory test
rG_Tory.bin <- glm(cbind(rG_Tory, rG_abund - rG_Tory) ~ Genotype,
                  data = filter(full.df, Genotype %in% rG.ptized.3plus.genos), 
                  family = 'binomial')
plot(rG_Tory.bin)
summary(rG_Tory.bin)
anova(rG_Tory.bin, test = "LR") # not significant

rG_Eulo.bin <- glm(cbind(rG_Eulo, rG_abund - rG_Eulo) ~ Genotype,
                  data = filter(full.df, Genotype %in% rG.ptized.3plus.genos), 
                  family = 'binomial')
plot(rG_Eulo.bin)
summary(rG_Eulo.bin)
anova(rG_Eulo.bin, test = "LR") # not significant

predict.df <- data.frame(Genotype = rG.ptized.3plus.genos)
rG.genotype.predictions <- cbind.data.frame(predict.df, 
                                         rG.Proportion.Ptized = predict(rG.ptized.bin,
                                                                               newdata = predict.df,
                                                                               type = "response"))
summary(rG.genotype.predictions)

ggplot(filter(rG.ptized.df, Genotype %in% rG.ptized.3plus.genos),
       aes(x = Genotype, y = rG_parasitized/rG_abund)) +
  geom_point(aes(size = rG_abund), color = "grey", shape = 1,
             position = position_jitter(height = 0, width = 0.1)) + 
  scale_size(range = c(3,15)) + 
  geom_point(data = rG.genotype.predictions, 
             aes(x = Genotype, y = rG.Proportion.Ptized),
             color = "steelblue", size = 30, shape = "--") +
  theme_classic() +
  ylab("Proportion of galls parasitized")
range(filter(rG.ptized.df, Genotype %in% rG.ptized.3plus.genos)$rG_abund)

## aSG parasitism
aSG.ptized.df <- full.df %>%
  filter(aSG_abund > 0)
table(aSG.ptized.df$Genotype)
aSG.ptized.3plus.genos <- c("G","I","K","Q") 

aSG.ptized.bin <- glm(cbind(aSG_parasitized, aSG_abund - aSG_parasitized) ~ Genotype,
                  data = filter(full.df, Genotype %in% aSG.ptized.3plus.genos), 
                  family = 'binomial')
plot(aSG.ptized.bin) # residuals not great
summary(aSG.ptized.bin)
anova(aSG.ptized.bin, test = "LR") # marginally significant after retaining Genotypes with 3 plus replicates.
predict.df <- data.frame(Genotype = aSG.ptized.3plus.genos)
aSG.genotype.predictions <- cbind.data.frame(predict.df, 
                                         aSG.Proportion.Ptized = predict(aSG.ptized.bin,
                                                                               newdata = predict.df,
                                                                               type = "response"))
summary(aSG.genotype.predictions)

ggplot(filter(aSG.ptized.df, Genotype %in% aSG.ptized.3plus.genos),
       aes(x = Genotype, y = aSG_parasitized/aSG_abund)) +
  geom_point(aes(size = aSG_abund), color = "grey", shape = 1,
             position = position_jitter(height = 0, width = 0.1)) + 
  scale_size(range = c(3,15)) + 
  geom_point(data = aSG.genotype.predictions, 
             aes(x = Genotype, y = aSG.Proportion.Ptized),
             color = "steelblue", size = 30, shape = "--") +
  theme_classic() +
  ylab("Proportion of galls parasitized")
range(filter(aSG.ptized.df, Genotype %in% aSG.ptized.3plus.genos)$aSG_abund)

## SG parasitism
SG.ptized.df <- full.df %>%
  filter(SG_abund > 0)
table(SG.ptized.df$Genotype) # no Genotypes with 3+ replicates, so I'm unable to evaluate whether SG parasitism defers among willow genotypes. 

##
uni.check.bin <- glm(vLG_Platy/vLG_abund ~ vLG_abund*vLG.height.mean, full.predictors,
                     family = binomial,
                     weights = vLG_abund)
AIC(uni.check.bin)
summary(uni.check.bin)
visreg(uni.check.bin, xvar = "vLG_abund", by = "vLG.height.mean", scale = "response")


# NEED TO THINK ABOUT HOW I SCALE THIS UP TO DIFFERENT NUMBERS OF SHOOTS SAMPLED.

#### messing around with different ideas.
## Create mvabund model based on probability of observing an interaction
prob.df <- full.predictors %>%
  mutate(succ.vLG_Platy.succ = vLG_Platy,
         fail.vLG_Platy.fail = vLG_abund - vLG_Platy,
         succ.vLG_Tory.succ = vLG_Tory,
         fail.vLG_Tory.fail = vLG_abund - vLG_Tory,
         succ.vLG_Mesopol.succ = vLG_Mesopol,
         fail.vLG_Mesopol.fail = vLG_abund - vLG_Mesopol,
         succ.vLG_Eulo.succ = vLG_Eulo,
         fail.vLG_Eulo.fail = vLG_abund - vLG_Eulo,
         succ.rG_Platy.succ = rG_Platy,
         fail.rG_Platy.fail = rG_abund - rG_Platy,
         succ.rG_Tory.succ = rG_Tory,
         fail.rG_Tory.fail = rG_abund - rG_Tory,
         succ.rG_Mesopol.succ = rG_Mesopol,
         fail.rG_Mesopol.fail = rG_abund - rG_Mesopol,
         succ.rG_Eulo.succ = rG_Eulo,
         fail.rG_Eulo.fail = rG_abund - rG_Eulo,
         succ.SG_Platy.succ = SG_Platy,
         fail.SG_Platy.fail = SG_abund - SG_Platy,
         succ.aSG_Tory.succ = aSG_Tory,
         fail.aSG_Tory.fail = aSG_abund - aSG_Tory) %>%
  select(succ.vLG_Platy.succ:fail.aSG_Tory.fail) %>%
  mvabund()

vLG.interaction.df <- mvabund(select(full.predictors, vLG_Eulo, vLG_Platy, vLG_Mymarid, vLG_Tory, vLG_Mesopol))
vLG.interaction.df[vLG.interaction.df > 0] <- 1

test <- manyglm(vLG.interaction.df ~ vLG_density*vLG.height.mean, data = full.predictors, family = "binomial")
plot(test)
anova(test, p.uni = "adjusted")
length(prob.df[prob.df > 1] > 0)

test <- MASS::glm.nb(vLG_Platy ~ offset(log(vLG_abund)) + vLG.height.mean, data = full.predictors) #
summary(test)
coef(test)
AIC(test)
#exp(sum(-4.5 + .34*5 -0.25*8))
exp(sum(coef(test)[c(1:3)]*c(1,0.02,8))) # 8 mm gall at a density of 11 per 100 shoots. Would be 6.11 parasitoids per 100 shoots.
predict(test, type = "response")*10
visreg(test, scale = "response")
```

```{r, functions, echo=FALSE}
kable.adonis <- function(adonis.object){
  require(knitr)
  kable(adonis.object$aov.tab[ ,-5], # remove R2 calculation
        col.names = c("df","SS","MS","F","P"), 
        digits = c(0,2,2,2,3))
}

heritability.adonis <- function(adonis.object, data){
  gen.row <- which(rownames(adonis.object$aov.tab) == "Genotype")
  res.row <- which(rownames(adonis.object$aov.tab) == "Residuals")
  gen.MS <- adonis.object$aov.tab$MeanSqs[gen.row]
  res.MS <- adonis.object$aov.tab$MeanSqs[res.row]
  mean.sample.size <- mean(table(data$Genotype))
  gen.variance <- (gen.MS - res.MS)/mean.sample.size
  heritability <- gen.variance/(gen.variance + res.MS) # note that residual MS is equal to the residual variance
  print(heritability)
}

heritability <- function(merMod.object){
  require(lme4)
  require(RLRsim)
  
  var.comps <- as.data.frame(VarCorr(merMod.object))
  genetic.var <- var.comps$vcov[1]
  residual.var <- var.comps$vcov[2]
  heritability <- genetic.var/(genetic.var + residual.var)
  restricted.likelihood.ratio.test <- exactRLRT(merMod.object)
  data.frame(#Model = formula(merMod.object),
             Heritability = round(heritability, 2),
             RLRT_statistic = round(restricted.likelihood.ratio.test$statistic, 2),
             P = round(restricted.likelihood.ratio.test$p.value, 3))
}



jensen.single <- function(model.object, predict.type = "response"){
  model <- model.object
  
  var.predict <- predict(model.object, type = predict.type)
  
  predictor.names <- names(model.object$model)[-1] # omits response variable
  data <- data.frame(model.object$model[ ,predictor.names])
  
  no.var.data <- list()
  for(i in 1:length(data)){
    no.var.data[[i]] <- mean(data[ ,i])
  }
  no.var.data <- as.data.frame(no.var.data)
  names(no.var.data) <- predictor.names
  
  no.var.predict <- predict(model.object, newdata = no.var.data, type = predict.type)
  
  data.frame(mean.with.var = mean(var.predict, na.rm = TRUE),
             mean.no.var = mean(no.var.predict, na.rm = TRUE))
}

jensen.single <- function(model.object, no.var.data, predict.type = "response"){
  model <- model.object
  
  var.predict <- predict(model.object, type = predict.type)
  
  predictor.names <- names(model.object$model)[-1] # omits response variable
  data <- data.frame(model.object$model[ ,predictor.names])
  
  #no.var.data <- list()
  #for(i in 1:length(data)){
   # no.var.data[[i]] <- mean(data[ ,i])
  #}
  #no.var.data <- as.data.frame(no.var.data)
  #names(no.var.data) <- predictor.names
  
  no.var.predict <- predict(model.object, newdata = no.var.data, type = predict.type)
  
  data.frame(mean.with.var = mean(var.predict, na.rm = TRUE),
             mean.no.var = mean(no.var.predict, na.rm = TRUE))
}

```

```{r}
library(psych)
gall.df.cors <- full.df %>%
  mutate(vLG_density = log(vLG_abund+1) - log(shootEst.no18),
         vLG_density2 = log(vLG_abund/shootEst.no18+0.01),
         vLG_density3 = sqrt(vLG_abund/shootEst.no18),
         rG_density = log(vLG_abund+1) - log(shootEst.no18),
         rG_density2 = log(rG_abund/shootEst.no18+0.01),
         rG_density3 = sqrt(rG_abund/shootEst.no18)) %>%
  select(vLG.height.mean, vLG_density:rG_density3)
trait.df.cors <- full.df %>%
  select(Total_Area:flavanonOLES.PC1)

gall.trait.cors <- corr.test(x = trait.df.cors, y = gall.df.cors)
round(gall.trait.cors$r,2)
# further examine all correlations greater than 0.20
# vLG.height.mean: salicortin__A270nm, luteolin.glucoside.5.glu.__A320nm, quercetyin.der1, luteolin.der1, luteolin der2, termulacin, Carbon, sal_tannin.PC1, flavonoOLES.PC1
# vLG_density: Total_Area, Height, D_mean_smoothed, ampelopsin.der__A320nm, myricitrin__A320nm, eriodictyol.7.glucoside__A270nm, luteolin.der1__A320nm, C_N_imputed (sal_tannin.PC1? a bit low). Note though the Nitrogen and C_N_ratio are not good predictors for the "un_imputed" data. 
# rG_density: total_area, height, D_mean_smoothed, ampelopsin.der__A320nm, eriodictyol.7.glucoside__A270nm, luteolin.der1__A320nm, C_N_imputed

library(car)
# need to work on code below.
scatterplotMatrix(cbind.data.frame(gall.df.cors$vLG.height.mean, 
                                   trait.df.cors[ ,"salicortin__A270nm", 
                                                 "luteolin.glucoside.5.glu.__A320nm",
                                                 "quercetin.der1__A320nm", 
                                                 "luteolin.der1__A320nm", 
                                                 "luteolin der2__A320nm", 
                                                 "termulacin__A320nm",
                                                 "Carbon", "sal_tannin.PC1", 
                                                 "flavonoOLES.PC1"]))
```

```{r}
interaction_abund <- rowSums(full.df[ ,interaxns_noPont])
interaction_richness <- rowSums(full.df[ ,interaxns_noPont] > 0)
ggplot(full.df, aes(x = Genotype, y = interaction_abund)) +
  geom_boxplot()

ggplot(full.df, aes(x = Genotype, y = interaction_abund/shootEst.no18)) +
  geom_boxplot() # G, H, M, N, O, P, R, U all have 75% of their observations at zero for interaction density

ggplot(full.df, aes(x = Genotype, y = interaction_richness)) +
  geom_boxplot() # G, H, M, N, O, P, R, U all have 75% of their observations at zero for interaction richness

non.zero.genos <- c("*","A","B","D","E","F","I","J","K","L","Q","S","T","V","W","X","Y","Z")

df.non.zero.genos <- filter(full.df, Genotype %in% non.zero.genos)
hist(log(rowSums(df.non.zero.genos[ ,interaxns_noPont]) +1))
interaction_abund.non.zero.genos <- rowSums(df.non.zero.genos[ ,interaxns_noPont])
library(lme4)
interaction.abund.lmer <- lmer(log(interaction_abund+1) ~ offset(log(shootEst.no18)) + (1|Genotype), full.df)
heritability(interaction.abund.lmer) # ~0.28 with non.zero.genos. 0.33 with full dataset, but the residuals look pretty good actually. Actually, setting an offset and log(x+1) transforming the response variable seems to do a pretty good job of making the random effect normally distributed.
ggQQ_ranef(ranef(interaction.abund.lmer)$Genotype$'(Intercept)')
hist(ranef(interaction.abund.lmer)$Genotype$'(Intercept)')
```

Table 1: Quantitative full data set with euclidean distance
```{r, results='asis', echo=FALSE}
full.adonis <- adonis(log(full.df.quant+1) ~ log(shootEst.no18) + Genotype, 
                      data = full.df, method = "euclidean")
heritability.adonis(full.adonis, full.df)
kable.adonis(full.adonis)
```

Table S2: Qualitative full data set with euclidean distance
```{r, results='asis', echo=FALSE}
full.adonis.qual <- adonis(full.df.qual ~ log(shootEst.no18) + Genotype, 
                      data = full.df, method = "euclidean")
heritability.adonis(full.adonis.qual, full.df)
kable.adonis(full.adonis.qual)
```

Table S3: Qualitative full data set with Raup-crick null model
```{r, results='asis', echo=FALSE}
rc.dist.full <- raupcrick(full.df.qual) # calculate raupcrick dissimilarity for teasing apart differences in alpha vs. beta-diversity
rc.dist.full.adonis <- adonis(rc.dist.full ~ log(shootEst.no18) + Genotype, 
                      data = full.df)
heritability.adonis(rc.dist.full.adonis, full.df)
kable.adonis(rc.dist.full.adonis)
```

Table S3: Qualitative sub data set with Raup-crick null model
```{r, results='asis', echo=FALSE}
rc.dist.sub <- raupcrick(sub.df.qual) # calculate raupcrick dissimilarity for teasing apart differences in alpha vs. beta-diversity
rc.dist.sub.adonis <- adonis(rc.dist.sub ~ log(shootEst.no18) + Genotype, 
                      data = sub.df)
heritability.adonis(rc.dist.sub.adonis, sub.df)
kable.adonis(rc.dist.sub.adonis)
```

Table S2: Quantitative data subset, euclidean
```{r, results='asis', echo=FALSE}
sub.adonis.euclid <- adonis(log(sub.df.quant+1) ~ log(shootEst.no18) + Genotype, 
                            data = sub.df, method = "euclidean")
kable.adonis(sub.adonis.euclid)
```

Table S3: Quantitative data subset, with bray-curtis dissimilarity
```{r, results='asis', echo=FALSE}
sub.adonis.bray <- adonis(sub.df.quant ~ log(shootEst.no18) + Genotype, 
                          data = sub.df, method = "bray")
kable.adonis(sub.adonis.bray)
```

Table S3: Qualitative data subset, with Jaccard dissimilarity
```{r, results='asis', echo=FALSE}
sub.adonis.jac <- adonis(sub.df.qual ~ log(shootEst.no18) + Genotype, 
                          data = sub.df, method = "jaccard")
heritability.adonis(adonis.object = sub.adonis.jac, data = sub.df)
kable.adonis(adonis.object = sub.adonis.jac)
```

Table S4: Qualitative data subset, with euclidean dissimilarity
```{r, results='asis', echo=FALSE}
sub.adonis.euc <- adonis(sub.df.qual ~ log(shootEst.no18) + Genotype, 
                          data = sub.df, method = "euclidean")
kable.adonis(adonis.object = sub.adonis.euc)
```

Heritability of focal gall-parasitoid guild interactions
```{r gall-ptoid heritability, echo=FALSE}
## Variation among genotypes
gall.ptoid.variation <- cbind(Genotype = full.df$Genotype, full.df[ ,c("vLG_egg","vLG_ecto","rG_ecto")]/full.df$shootEst.no18) %>%
  group_by(Genotype) %>%
  select(vLG_egg, vLG_ecto, rG_ecto) %>%
  summarise_each(funs(mean))

max(filter(gall.ptoid.variation, vLG_egg > 0)$vLG_egg)/min(filter(gall.ptoid.variation, vLG_egg > 0)$vLG_egg) # 35-fold variation in vLG_egg parasitism among genotypes that hosted this interaction

max(filter(gall.ptoid.variation, vLG_ecto > 0)$vLG_ecto)/min(filter(gall.ptoid.variation, vLG_ecto > 0)$vLG_ecto) # 20-fold variation in vLG_ecto parasitism among genotypes that hosted this interaction

max(filter(gall.ptoid.variation, rG_ecto > 0)$rG_ecto)/min(filter(gall.ptoid.variation, rG_ecto > 0)$rG_ecto) # 9-fold variation in vLG_ecto parasitism among genotypes that hosted this interaction

## Iteomyia (vLG) - Egg parasitoid 
vLG_egg.lmer.full <- lmer(log(vLG_egg + 1) ~ log(shootEst.no18) + (1|Genotype), 
                          data = full.df)
heritability(vLG_egg.lmer.full)
ggQQ_ranef(ranef(vLG_egg.lmer.full)$Genotype$"(Intercept)") # non-normal random effect

vLG_egg.lmer.sub <- lmer(log(vLG_egg + 1) ~ log(shootEst.no18) + (1|Genotype), 
                         data = sub.df)
heritability(vLG_egg.lmer.sub)
ggQQ_ranef(ranef(vLG_egg.lmer.sub)$Genotype$"(Intercept)") # normal random effect

## Iteomyia (vLG) - Larval parasitoid (ecto)
vLG_ecto.lmer.full <- lmer(log(vLG_ecto + 1) ~ log(shootEst.no18) + (1|Genotype), 
                          data = full.df)
heritability(vLG_ecto.lmer.full)
ggQQ_ranef(ranef(vLG_ecto.lmer.full)$Genotype$"(Intercept)") # close to normal random effect

vLG_ecto.lmer.sub <- lmer(log(vLG_ecto + 1) ~ log(shootEst.no18) + (1|Genotype), 
                         data = sub.df)
heritability(vLG_ecto.lmer.sub) # marginally significant
ggQQ_ranef(ranef(vLG_ecto.lmer.sub)$Genotype$"(Intercept)") # normal random effect

## Rabdophaga salicisbrassicoides (rG) - Larval parasitoid (ecto)
rG_ecto.lmer.full <- lmer(log(rG_ecto + 1) ~ log(shootEst.no18) + (1|Genotype), 
                          data = full.df)
heritability(rG_ecto.lmer.full)
ggQQ_ranef(ranef(rG_ecto.lmer.full)$Genotype$"(Intercept)") # non-normal random effect

rG_ecto.lmer.sub <- lmer(log(rG_ecto + 1) ~ log(shootEst.no18) + (1|Genotype), 
                         data = sub.df)
heritability(rG_ecto.lmer.sub)
ggQQ_ranef(ranef(rG_ecto.lmer.sub)$Genotype$"(Intercept)") # close to normal random effect
```

Gall density and gall size variation among willow genotypes
```{r}
gall.density.variation <- cbind(Genotype = full.df$Genotype, full.df[ ,c("vLG_abund","rG_abund")]/full.df$shootEst.no18) %>%
  group_by(Genotype) %>%
  select(vLG_abund, rG_abund) %>%
  summarise_each(funs(mean))

max(filter(gall.density.variation, vLG_abund > 0)$vLG_abund)/min(filter(gall.density.variation, vLG_abund > 0)$vLG_abund) # 67-fold variation in Iteomyia among willow genotypes

max(filter(gall.density.variation, rG_abund > 0)$rG_abund)/min(filter(gall.density.variation, rG_abund > 0)$rG_abund) # 62-fold variation in Rabdophaga-bud among willow genotypes.

vLG.lmer.full <- lmer(log(vLG_abund + 1) ~ log(shootEst.no18) + (1|Genotype),
                      data = full.df)
heritability(merMod.object = vLG.lmer.full)

rG.lmer.full <- lmer(log(rG_abund + 1) ~ log(shootEst.no18) + (1|Genotype),
                      data = full.df)
heritability(merMod.object = rG.lmer.full)

## vLG size. To test this, I took advantage of the full gall data set and used a nested random effect model.
vLG.size.df <- filter(gall.size.df, gall.sp == "vLG")
table(vLG.size.df$Genotype) # large heterogeneity in sample sizes
table(vLG.size.df$plant.position) # large heterogeneity in sample sizes

vLG.size.lmer <- lmer(gall.height ~ 1 + (1 | Genotype) + (1 |plant.position:Genotype),
                      data = vLG.size.df)
vLG.size.lmer.gen <- update(vLG.size.lmer, .~. - (1 | plant.position:Genotype)) # only Genotype as random effect
vLG.size.lmer.pp <- update(vLG.size.lmer, .~. - (1 | Genotype)) # only plant.position as random effect

vLG.size.lmer.sum <- summary(vLG.size.lmer)
summary(vLG.size.lmer.gen)
summary(vLG.size.lmer.pp)

gen.var <- vLG.size.lmer.sum$varcor$Genotype[1] # Variance due to Genotype
pp.var <- vLG.size.lmer.sum$varcor$'plant.position:Genotype'[1] # variance due to plant position
res.var <- 4.1133 # residual variance - don't know how to extract this from summary object.

H2.vLG.size <- gen.var/(gen.var + pp.var + res.var) # 0.15
exactRLRT(m = vLG.size.lmer.gen, mA = vLG.size.lmer, m0 = vLG.size.lmer.pp) # this model tests whether 

## rG size. To test this, I took advantage of the full gall data set and used a nested random effect model.
rG.size.df <- filter(gall.size.df, gall.sp == "rG")
table(rG.size.df$Genotype) # large heterogeneity in sample sizes
table(rG.size.df$plant.position) # large heterogeneity in sample sizes

rG.size.lmer <- lmer(gall.height ~ 1 + (1 | Genotype) + (1 |plant.position:Genotype),
                      data = rG.size.df)
rG.size.lmer.gen <- update(rG.size.lmer, .~. - (1 | plant.position:Genotype)) # only Genotype as random effect
rG.size.lmer.pp <- update(rG.size.lmer, .~. - (1 | Genotype)) # only plant.position as random effect

rG.size.lmer.sum <- summary(rG.size.lmer)
summary(rG.size.lmer.gen)
summary(rG.size.lmer.pp)

gen.var <- rG.size.lmer.sum$varcor$Genotype[1] # Variance due to Genotype
pp.var <- rG.size.lmer.sum$varcor$'plant.position:Genotype'[1] # variance due to plant position
res.var <- 1.80518 # residual variance - don't know how to extract this from summary object.

H2.rG.size <- gen.var/(gen.var + pp.var + res.var) # 0.0418
exactRLRT(m = rG.size.lmer.gen, mA = rG.size.lmer, m0 = rG.size.lmer.pp) # this model tests whether 
```


RDA analysis of community response to Iteomyia density and size as well as R. salicisbrassicoides density
```{r RDA, echo=FALSE}
full.rda.df <- full.df %>%
  filter(vLG.height.mean > 0) %>% 
  mutate(vLG_density = vLG_abund/shootEst.no18,
         rG_density = rG_abund/shootEst.no18)
full.rda.df.interaxn <- full.rda.df[ ,interaxns_noPont]
full.rda.df.interaxn.qual <- ifelse(full.rda.df[ ,interaxns_noPont] > 0, 1, 0)

full.rda.df.interaxn.log1 <- log(full.rda.df.interaxn+1)
full.rda.df.interaxn.log1.offset <- full.rda.df.interaxn.log1 - log(full.rda.df$shootEst.no18) # this is the same as applying an "offset" to all of the data. In other words, to interpret it in terms of density

rda.full <- rda(full.rda.df.interaxn.log1.offset ~  
                  vLG_density*vLG.height.mean + rG_density, data = full.rda.df)
RsquareAdj(rda.full)
anova(rda.full)
anova(rda.full, by = "margin")

rda.traits.df <- na.omit(data.frame(full.rda.df.interaxn, 
                                  shootEst.no18 = full.rda.df$shootEst.no18,
                                  C_N_imputed = full.rda.df$C_N_imputed, 
                                  Height = full.rda.df$Height, 
                                  sal_tannin.PC1 = full.rda.df$sal_tannin.PC1, 
                                  flavonOLES.PC1 = full.rda.df$flavonOLES.PC1))
rda.full.traits <- rda(log(rda.traits.df[ ,interaxns_noPont]+1) ~ 
                         Condition(log(shootEst.no18)) + 
                         sal_tannin.PC1, data = rda.traits.df)
RsquareAdj(rda.full.traits)
anova(rda.full.traits)
anova(rda.full.traits, by = "margin")
vif.cca(rda.full.traits)
plot(rda.full.traits)

rda.full.qual <- rda(full.rda.df.interaxn.qual ~  
                  vLG_density + vLG.height.mean + rG_density, data = full.rda.df)
RsquareAdj(rda.full.qual)
anova(rda.full.qual)
anova(rda.full.qual, by = "margin")

pos.interactions <- which(rowSums(full.rda.df.interaxn.qual) > 0)
rda.full.qual.jac <- capscale(full.rda.df.interaxn.qual[pos.interactions, ] ~  
                  vLG_density+vLG.height.mean + rG_density, 
                  data = full.rda.df[pos.interactions, ], distance = "jaccard")
RsquareAdj(rda.full.qual.jac)
plot(rda.full.qual.jac)
anova(rda.full.qual.jac)
anova(rda.full.qual.jac, by = "margin")
vif.cca(rda.full.qual.jac)

## vLG-egg parasitoid response
vLG_egg.lm <- lm(log(vLG_egg + 1) ~ offset(log(shootEst.no18)) + 
                   vLG_density*vLG.height.mean,
                 data = full.rda.df)
summary(vLG_egg.lm)
plot(vLG_egg.lm)
library(visreg)
visreg(vLG_egg.lm, xvar = "vLG_density", by = "vLG.height.mean")

## vLG-ecto parasitoid response
vLG_ecto.lm <- lm(log(vLG_ecto+1) ~ offset(log(shootEst.no18)) + vLG_density + vLG.height.mean,
                 data = full.rda.df)
summary(vLG_ecto.lm)
plot(vLG_ecto.lm)

## rG-ecto parasitoid response
rG_ecto.lm <- lm(log(rG_ecto+1) ~ offset(log(shootEst.no18)) + rG_density,
                 data = full.rda.df)
summary(rG_ecto.lm)

```

```{r functional responses}
library(ggplot2)
full.rda.df.small.galls <- filter(full.rda.df, vLG.height.mean < 8)
ggplot(full.rda.df.small.galls, aes(x = vLG_density, y = vLG_egg/vLG_abund)) +
  geom_point(aes(size = vLG_abund)) +
  stat_smooth(method = "glm", family = binomial, aes(weight = full.rda.df.small.galls$vLG_abund))

vLG_egg.bin <- glm(cbind(vLG_egg, vLG_abund - vLG_egg) ~ vLG_density*vLG.height.mean, 
                   data = full.rda.df, family = binomial)
summary(vLG_egg.bin)
anova(update(vLG_egg.bin, .~. - vLG_density*vLG.height.mean), vLG_egg.bin, test = "Chi")

plot(vLG_egg.bin)
visreg(vLG_egg.bin, xvar = "vLG_density", by = "vLG.height.mean", scale = "response")
visreg2d(vLG_egg.bin, x = "vLG.height.mean", y = "vLG_density", scale = "response")

vLG_ecto.bin <- glm(cbind(vLG_ecto, vLG_abund - vLG_ecto) ~ vLG_density + vLG.height.mean,
                    data = full.rda.df, family = binomial)
summary(vLG_ecto.bin)
anova(update(vLG_ecto.bin, .~. - vLG_density - vLG.height.mean), vLG_ecto.bin, test = "Chi")
plot(vLG_ecto.bin)
visreg(vLG_ecto.bin, scale = "response")
visreg2d(vLG_ecto.bin, x = "vLG.height.mean", y = "vLG_density", scale = "response")

rG_ecto.bin <- glm(cbind(rG_ecto, rG_abund - rG_ecto) ~ I(rG_abund/shootEst.no18),
                    data = full.df, family = binomial)
summary(rG_ecto.bin)
anova(update(rG_ecto.bin, .~. - I(rG_abund/shootEst.no18)), rG_ecto.bin, test = "Chi")
plot(rG_ecto.bin)
```

```{r}
# try mantel test
data.for.mantel <- na.omit(select(full.df, plant.position, shootEst.no18,
                                  aSG_Tory:rG_Platy, rG_Tory, SG_Platy, vLG_Eulo:vLG_Tory, # all interactions
                                  Total_Area:HCH.tremulacin.__A220nm, water_content,
                                  specific_leaf_area, C_N_imputed))
traits.stand <- decostand(select(data.for.mantel, Total_Area:C_N_imputed), method = "standardize")
traits.dist <- vegdist(traits.stand, method = "euclidean")
network.stand <- (select(data.for.mantel, aSG_Tory:vLG_Tory)/data.for.mantel$shootEst.no18)
network.dist <- vegdist(network.stand, method = "euclidean")

network.for.dist <- mantel(xdis = traits.dist, ydis = network.dist)

```

Gall density mechanisms
```{r}
traits <- full.df %>%
  select(plant.position,
         Total_Area, Height, Density, # architecture traits
         Trichome.No., specific_leaf_area, water_content, C_N_imputed, # other leaf quality traits
         sal_tannin.PC1, cinn.PC1, cinn.PC2, # salicylates/tannins and phenolic acids
         flavonOLES.PC1, flavonOLES.PC2, flavanonOLES.PC1) %>% # flavonoids
  mutate(log_size = log(Total_Area),
         log_trichomes = log(Trichome.No.+1))
traits <- na.omit(traits)
height_resid <- residuals(lm(Height ~ log_size, traits))
density_resid <- residuals(lm(Density ~ log_size, traits))
sla_resid <- residuals(lm(specific_leaf_area ~ water_content, traits))

traits.df <- cbind.data.frame(select(traits, plant.position, water_content:log_trichomes), 
                              height_resid, density_resid, sla_resid)

trait.names <- colnames(traits.df)[-1]

gall.density.size.df <- full.df %>% 
  select(vLG_abund, rG_abund, shootEst.no18, plant.position, vLG.height.mean) %>%
  mutate(vLG_density = vLG_abund/shootEst.no18,
         rG_density = rG_abund/shootEst.no18) %>%
  select(plant.position:rG_density)

gall.density.size.traits.df <- left_join(gall.density.size.df, traits.df)
vLG.df <- na.omit(select(gall.density.size.traits.df, vLG_density, water_content:sla_resid))
vLG.size.df <- na.omit(select(gall.density.size.traits.df, vLG.height.mean, water_content:sla_resid))
rG.df <- na.omit(select(gall.density.size.traits.df, rG_density, water_content:sla_resid))
#focal.df <- na.omit(gall.density.size.traits.df)
#focal.df.traits <- focal.df[ ,trait.names]

# Iteomyia salicisverruca (vLG) abundance model
vLG.dens.glm <- glm(vLG_abund > 0 ~ offset(log(shootEst.no18)) + C_N_imputed + Total_Area + sal_tannin.PC1, full.df, family = binomial)
summary(vLG.dens.glm)
plot(vLG.dens.glm)

vLG.dens.lm <- lm(log(vLG_abund) ~ offset(log(shootEst.no18)) + C_N_imputed + Total_Area + sal_tannin.PC1, filter(full.df, vLG_abund > 0))
summary(vLG.dens.lm)
plot(vLG.dens.lm)
visreg(vLG.dens.lm)

plot(log(vLG_abund/shootEst.no18) ~ sal_tannin.PC1, filter(full.df, vLG_abund > 0))
library(MuMIn)

dredge(vLG.full)
vLG.null <- lm(vLG.df$vLG_density ~ 1, vLG.df[ ,trait.names])
vLG.full <- lm(vLG.df$vLG_density ~ ., vLG.df[ ,trait.names])
summary(vLG.full) # adj. R2 = 0.03 DOESN'T PASS THE TEST!!!
vLG.step <- step(vLG.null, scope = formula(vLG.full), direction = "forward")
vLG.update <- update(vLG.null, .~. + sal_tannin.PC1 + log_size + height_resid) 
summary(vLG.update)
#plot(vLG.update)

vLG.size.null <- lm(vLG.size.df$vLG.height.mean ~ 1, vLG.size.df[ ,trait.names])
vLG.size.full <- lm(vLG.size.df$vLG.height.mean ~ ., vLG.size.df[ ,trait.names])
summary(vLG.size.full) # adj. R2 = 0.03 DOESN'T PASS THE TEST!!!
vLG.size.step <- step(vLG.size.null, scope = formula(vLG.size.full), direction = "forward")
vLG.size.update <- update(vLG.size.null, .~. + flavonOLES.PC1) 
summary(vLG.size.update)

rG.null <- lm(rG.df$rG_density ~ 1, rG.df[ ,trait.names])
rG.full <- lm(rG.df$rG_density ~ ., rG.df[ ,trait.names])
summary(rG.full) # adj. R2 = 0.12 DOESN'T PASS THE TEST!!!
rG.step <- step(rG.null, scope = formula(rG.full), direction = "forward")
rG.update <- update(rG.null, .~. + log_size  + height_resid + 
    density_resid) 
summary(rG.update)

```